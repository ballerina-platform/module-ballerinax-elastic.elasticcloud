// AUTO-GENERATED FILE. DO NOT MODIFY.
// This file is auto-generated by the Ballerina OpenAPI tool.

import ballerina/data.jsondata;
import ballerina/http;

# The container for a set of traffic filter rulesets
public type TrafficFilterRulesets record {
    # List of traffic filter rules
    TrafficFilterRulesetInfo[] rulesets;
};

# The configuration settings for the timeout and fallback parameters
public type ElasticsearchPlanControlConfiguration record {
    # Set to 'forced' to force a reboot as part of the upgrade plan. NOTES: (ie taking an existing plan and leaving it alone except for setting 'transient.plan_configuration.cluster_reboot': 'forced' will reboot the cluster)
    @jsondata:Name {value: "cluster_reboot"}
    "forced" clusterReboot?;
    # This timeout determines how long to give a cluster after it responds to API calls before performing actual operations on it. It defaults to 5s
    @jsondata:Name {value: "calm_wait_time"}
    int calmWaitTime?;
    # If taking a snapshot (ie unless 'skip_snapshots': true) then will retry on failure at most this number of times (default: 5)
    @jsondata:Name {value: "max_snapshot_attempts"}
    int:Signed32 maxSnapshotAttempts?;
    # When you take a snapshot and 'skip_snapshots' is false, specifies the maximum age in seconds of the most recent snapshot before a new snapshot is created. Default is 300
    @jsondata:Name {value: "max_snapshot_age"}
    int maxSnapshotAge?;
    # The total timeout in seconds after which the plan is cancelled even if it is not complete. Defaults to 4x the max memory capacity per node (in MB). NOTES: A 3 zone cluster with 2 nodes of 2048 each would have a timeout of 4*2048=8192 seconds. Timeout does not include time required to run rollback actions
    int timeout?;
    # If true (default: false), does not take (or require) a successful snapshot to be taken before performing any potentially destructive changes to this cluster
    @jsondata:Name {value: "skip_snapshot"}
    boolean skipSnapshot?;
    # If true (default false), does not clear the maintenance flag (which prevents its API from being accessed except by the constructor) on new instances added until after a snapshot has been restored, otherwise, the maintenance flag is cleared once the new instances successfully join the new cluster
    @jsondata:Name {value: "extended_maintenance"}
    boolean extendedMaintenance?;
};

# An AppSearch creation request paired with the alias of the Elasticsearch cluster it should be paired with
public type AppSearchPayload record {
    # A locally-unique user-specified id for AppSearch
    @jsondata:Name {value: "ref_id"}
    string refId;
    # The settings for the App Search
    AppSearchSettings settings?;
    # Alias to the Elasticsearch Cluster to attach AppSearch to
    @jsondata:Name {value: "elasticsearch_cluster_ref_id"}
    string elasticsearchClusterRefId;
    # The human readable name for the AppSearch cluster (default: takes the name of its Elasticsearch cluster)
    @jsondata:Name {value: "display_name"}
    string displayName?;
    # The region where this resource exists
    string region;
    # The plan for the App Search cluster
    AppSearchPlan plan;
};

# The response to an APM CRUD (create/update-plan) request
public type ApmCrudResponse record {
    # If the endpoint is called with URL param 'validate_only=true', then this contains advanced debug info (the internal plan representation)
    record {} diagnostics?;
    # The secret token for accessing the server
    @jsondata:Name {value: "secret_token"}
    string secretToken;
    # For an operation creating or updating an APM server, the Id of that server
    @jsondata:Name {value: "apm_id"}
    string apmId?;
};

# Information about the APM Servers associated with the Elasticsearch cluster
public type AppSearchSubInfo record {
    # A map of application-specific operations (which map to 'operationId's in the Swagger API) to metadata about that operation
    record {|Hyperlink...;|} links?;
    # The App Search Id
    @jsondata:Name {value: "app_search_id"}
    string appSearchId;
    # Whether the associated App Search is currently available
    boolean enabled;
};

# Defines the topology of the Enterprise Search nodes (e.g. number/capacity of nodes, and where they can be allocated)
public type EnterpriseSearchTopologyElement record {
    # Controls the allocation of this topology element as well as allowed sizes and node_types. It needs to match the id of an existing instance configuration
    @jsondata:Name {value: "instance_configuration_id"}
    string instanceConfigurationId?;
    # The version of the Instance Configuration Id. If it is unset, the meaning depends on read vs writes. For deployment reads, it is equivalent to version 0 (or the IC is unversioned); for deployment creates and deployment template use, it is equivalent to 'the latest version'; and for deployment updates, it is equivalent to 'retain the current version'
    @jsondata:Name {value: "instance_configuration_version"}
    int:Signed32 instanceConfigurationVersion?;
    @jsondata:Name {value: "memory_per_node"}
    record {} memoryPerNode?;
    @jsondata:Name {value: "node_type"}
    EnterpriseSearchNodeTypes nodeType?;
    @jsondata:Name {value: "enterprise_search"}
    EnterpriseSearchConfiguration enterpriseSearch?;
    # Measured by the amount of a resource. The final cluster size is calculated using multipliers from the topology instance configuration
    TopologySize size?;
    # number of zones in which nodes will be placed
    @jsondata:Name {value: "zone_count"}
    int:Signed32 zoneCount?;
    @jsondata:Name {value: "node_configuration"}
    string nodeConfiguration?;
    @jsondata:Name {value: "node_count_per_zone"}
    record {} nodeCountPerZone?;
    @jsondata:Name {value: "allocator_filter"}
    record {} allocatorFilter?;
};

# Represents the Queries record for the operation: migrate-deployment-template
public type MigrateDeploymentTemplateQueries record {
    # The ID of the deployment template to migrate to
    @http:Query {name: "template_id"}
    string templateId;
};

# Defines the configuration parameters that control how the plan is applied. For example, the Elasticsearch cluster topology and Integrations Server settings
public type TransientIntegrationsServerPlanConfiguration record {
    @jsondata:Name {value: "plan_configuration"}
    IntegrationsServerPlanControlConfiguration planConfiguration?;
    # The options for performing a plan change. Specify only one property each time. The default is `grow_and_shrink`
    PlanStrategy strategy?;
};

# Information about the Integrations Server plan
public type IntegrationsServerPlanInfo record {
    # Either the plan ended successfully, or is not yet completed (and no errors have occurred)
    boolean healthy;
    ClusterPlanWarning[] warnings;
    # If this plan completed or failed (ie is not pending), when the attempt ended (ISO format in UTC)
    @jsondata:Name {value: "attempt_end_time"}
    string attemptEndTime?;
    # A container for information about the source of a change
    ChangeSourceInfo 'source?;
    # Information about an error during a plan attempt
    ClusterPlanAttemptError 'error?;
    # The plan for the Integrations Server
    IntegrationsServerPlan plan?;
    @jsondata:Name {value: "plan_attempt_log"}
    ClusterPlanStepInfo[] planAttemptLog;
    # If this plan is not current or pending, when the plan was no longer active (ISO format in UTC)
    @jsondata:Name {value: "plan_end_time"}
    string planEndTime?;
    # A UUID for each plan attempt
    @jsondata:Name {value: "plan_attempt_id"}
    string planAttemptId?;
    # A human readable name for each plan attempt, only populated when retrieving plan histories
    @jsondata:Name {value: "plan_attempt_name"}
    string planAttemptName?;
    # When this plan attempt (ie to apply the plan to the Integrations Server) started (ISO format in UTC)
    @jsondata:Name {value: "attempt_start_time"}
    string attemptStartTime?;
};

# The Kibana instance settings. When specified at the top level, provides a field-by-field default. When specified at the topology level, provides the override settings
public type KibanaConfiguration record {
    # An arbitrary JSON object allowing (non-admin) cluster owners to set their parameters (only one of this and 'user_settings_yaml' is allowed), provided the parameters are on the allowlist and not on the denylist. (This field together with 'user_settings_override*' and 'system_settings' defines the total set of Kibana settings)
    @jsondata:Name {value: "user_settings_json"}
    record {} userSettingsJson?;
    @jsondata:Name {value: "system_settings"}
    KibanaSystemSettings systemSettings?;
    # An arbitrary YAML object allowing (non-admin) cluster owners to set their parameters (only one of this and 'user_settings_json' is allowed), provided the parameters are on the allowlist and not on the denylist. (These field together with 'user_settings_override*' and 'system_settings' defines the total set of Kibana settings)
    @jsondata:Name {value: "user_settings_yaml"}
    string userSettingsYaml?;
    # An arbitrary JSON object allowing ECE admins owners to set clusters' parameters (only one of this and 'user_settings_override_yaml' is allowed), ie in addition to the documented 'system_settings'. (This field together with 'system_settings' and 'user_settings*' defines the total set of Kibana settings)
    @jsondata:Name {value: "user_settings_override_json"}
    record {} userSettingsOverrideJson?;
    # The version of the Kibana cluster (must be one of the ECE supported versions, and won't work unless it matches the Elasticsearch version. Leave blank to auto-detect version.)
    string version?;
    # A docker URI that allows overriding of the default docker image specified for this version
    @jsondata:Name {value: "docker_image"}
    string dockerImage?;
    # An arbitrary YAML object allowing ECE admins owners to set clusters' parameters (only one of this and 'user_settings_override_json' is allowed), ie in addition to the documented 'system_settings'. (This field together with 'system_settings' and 'user_settings*' defines the total set of Kibana settings)
    @jsondata:Name {value: "user_settings_override_yaml"}
    string userSettingsOverrideYaml?;
};

# The status of your cluster and its readiness to be upgraded
public type DeploymentUpgradeAssistantStatusResponse record {
    # A boolean indicating whether or not the cluster is ready to be upgraded
    @jsondata:Name {value: "ready_for_upgrade"}
    boolean readyForUpgrade;
    # Message with information about the number of Elasticsearch and Kibana deprecations
    string details;
};

# Represents the Queries record for the operation: get-deployment-upgrade-assistant-status
public type GetDeploymentUpgradeAssistantStatusQueries record {
    # If present, value is included in resource request to provide additional context (only supported for Kibana)
    @http:Query {name: "target_version"}
    string targetVersion?;
};

public type ExternalHyperlink record {
    # Identifier of the external link
    string id;
    # Human-readable description of the external link
    string label;
    # hyperlink to an external resource
    string uri?;
};

# Provides a set of configurations for controlling the behaviours when communicating with a remote HTTP endpoint.
@display {label: "Connection Config"}
public type ConnectionConfig record {|
    # The HTTP version understood by the client
    http:HttpVersion httpVersion = http:HTTP_2_0;
    # Configurations related to HTTP/1.x protocol
    http:ClientHttp1Settings http1Settings = {};
    # Configurations related to HTTP/2 protocol
    http:ClientHttp2Settings http2Settings = {};
    # The maximum time to wait (in seconds) for a response before closing the connection
    decimal timeout = 30;
    # The choice of setting `forwarded`/`x-forwarded` header
    string forwarded = "disable";
    # Configurations associated with Redirection
    http:FollowRedirects followRedirects?;
    # Configurations associated with request pooling
    http:PoolConfiguration poolConfig?;
    # HTTP caching related configurations
    http:CacheConfig cache = {};
    # Specifies the way of handling compression (`accept-encoding`) header
    http:Compression compression = http:COMPRESSION_AUTO;
    # Configurations associated with the behaviour of the Circuit Breaker
    http:CircuitBreakerConfig circuitBreaker?;
    # Configurations associated with retrying
    http:RetryConfig retryConfig?;
    # Configurations associated with cookies
    http:CookieConfig cookieConfig?;
    # Configurations associated with inbound response size limits
    http:ResponseLimitConfigs responseLimits = {};
    # SSL/TLS-related options
    http:ClientSecureSocket secureSocket?;
    # Proxy server related options
    http:ProxyConfig proxy?;
    # Provides settings related to client socket configuration
    http:ClientSocketConfig socketConfig = {};
    # Enables the inbound payload validation functionality which provided by the constraint package. Enabled by default
    boolean validation = true;
    # Enables relaxed data binding on the client side. When enabled, `nil` values are treated as optional, 
    # and absent fields are handled as `nilable` types. Enabled by default.
    boolean laxDataBinding = true;
|};

# Represents the Queries record for the operation: create-deployment
public type CreateDeploymentQueries record {
    # If true, will just validate the Deployment definition but will not perform the creation
    boolean validate_only = false;
    # An optional template id - if present, the referenced template will be used to fill in the resources field of the deployment creation request. If any resources are present in the request together with the template, the ones coming in the request will prevail and no merging with the template will be performed
    string template_id?;
    # An optional idempotency token - if two create requests share the same request_id token (min size 32 characters, max 128) then only one deployment will be created, the second request will return the info of that deployment (in the same format described below, but with blanks for auth-related fields)
    string request_id?;
};

# Additional configuration about the current deployment object
public type DeploymentSettings record {
    @jsondata:Name {value: "auto_ops"}
    AutoOpsSettings autoOps;
    # An optional string that declares the deployment's expected application. Example supported values are: elasticsearch, observability, security
    @jsondata:Name {value: "solution_type"}
    string solutionType?;
    # If autoscaling is enabled for this deployment
    @jsondata:Name {value: "autoscaling_enabled"}
    boolean autoscalingEnabled?;
    @jsondata:Name {value: "traffic_filter_settings"}
    TrafficFilterSettings trafficFilterSettings?;
    # The observability settings for a deployment
    DeploymentObservabilitySettings observability?;
};

# Represents the Queries record for the operation: update-deployment
public type UpdateDeploymentQueries record {
    # Whether or not to hide orphaned resources that were shut down (relevant if prune on the request is true)
    @http:Query {name: "hide_pruned_orphans"}
    boolean hidePrunedOrphans = false;
    # If true, will just validate the Deployment definition but will not perform the update
    @http:Query {name: "validate_only"}
    boolean validateOnly = false;
    # If specified then checks for conflicts against the version stored in the persistent store (returned in 'x-cloud-resource-version' of the GET request)
    string version?;
    # Whether or not to skip snapshots before shutting down orphaned resources (relevant if prune on the request is true)
    @http:Query {name: "skip_snapshot"}
    boolean skipSnapshot = false;
};

# The request payload that creates the API keys
public type CreateApiKeyRequest record {
    @jsondata:Name {value: "role_assignments"}
    RoleAssignments roleAssignments?;
    # API key description. Useful if there are multiple keys
    string description;
    # The optional expiration for the API key, provided as a duration (ex: '1d', '3h')
    string expiration?;
};

# Data for a deployment resource
public type DeploymentResource record {
    # A locally-unique friendly alias for this Elasticsearch cluster
    @jsondata:Name {value: "ref_id"}
    string refId;
    # The Elasticsearch cluster that this resource depends on
    @jsondata:Name {value: "elasticsearch_cluster_ref_id"}
    string elasticsearchClusterRefId?;
    # The username and password for the new Elasticsearch cluster, which is returned from the Elasticsearch cluster `create` command
    ClusterCredentials credentials?;
    # The kind of resource
    string kind;
    # List of warnings generated from validating resource updates
    ReplyWarning[] warnings?;
    # A system-unique id for the created resource
    string id;
    # An encoded string that provides other Elastic services with the necessary information to connect to this Elasticsearch and Kibana
    @jsondata:Name {value: "cloud_id"}
    string cloudId?;
    # Identifier of the region in which this resource runs
    string region;
    # Secret token for using a created resource. Only provided on initial create and absent otherwise
    @jsondata:Name {value: "secret_token"}
    string secretToken?;
};

# The overview information for the App Search Server
public type AppSearchInfo record {
    # The settings for the App Search
    AppSearchSettings settings?;
    # Information about the public and internal state, and the configuration settings of an Elasticsearch cluster
    ClusterMetadataInfo metadata?;
    # The topology for Elasticsearch clusters, multiple Kibana instances, or multiple APM Servers. The `ClusterTopologyInfo` also includes the instances and containers, and where they are located
    ClusterTopologyInfo topology;
    @jsondata:Name {value: "plan_info"}
    AppSearchPlansInfo planInfo;
    @jsondata:Name {value: "elasticsearch_cluster"}
    TargetElasticsearchCluster elasticsearchCluster;
    # Whether the App Search is healthy or not (one or more of the info subsections will have healthy: false)
    boolean healthy;
    # External resources related to the App Search
    @jsondata:Name {value: "external_links"}
    ExternalHyperlink[] externalLinks;
    # The name of the App Search
    string name;
    # A map of application-specific operations (which map to 'operationId's in the Swagger API) to metadata about that operation
    record {|Hyperlink...;|} links?;
    # The id of the App Search
    string id;
    # The id of the deployment that this App Search belongs to
    @jsondata:Name {value: "deployment_id"}
    string deploymentId?;
    # The region that this App Search belongs to. Only populated in SaaS or federated ECE
    string region?;
    # App Search status
    "initializing"|"stopping"|"stopped"|"rebooting"|"restarting"|"reconfiguring"|"started" status;
};

# Matches documents that have at least one non-`null` value in the original field
public type ExistsQuery record {
    # The field to check for non-null values in
    string 'field;
};

# Information about the monitoring status for the Elasticsearch cluster
public type ElasticsearchMonitoringInfo record {
    # The list of clusters Ids from which this cluster is currently receiving monitoring data
    @jsondata:Name {value: "source_cluster_ids"}
    string[] sourceClusterIds;
    # The list of clusters Ids to which this cluster is currently sending monitoring data
    @jsondata:Name {value: "destination_cluster_ids"}
    string[] destinationClusterIds;
    # Whether the Monitoring configuration has been successfully applied
    boolean healthy;
    # The status message from the last update (successful or not)
    @jsondata:Name {value: "last_update_status"}
    string lastUpdateStatus;
    # The time the monitoring configuration was last changed
    @jsondata:Name {value: "last_modified"}
    string lastModified;
};

# Information about the current, pending, or past Kibana instance plan
public type KibanaClusterPlanInfo record {
    # Either the plan ended successfully, or is not yet completed (and no errors have occurred)
    boolean healthy;
    ClusterPlanWarning[] warnings;
    # If this plan completed or failed (ie is not pending), when the attempt ended (ISO format in UTC)
    @jsondata:Name {value: "attempt_end_time"}
    string attemptEndTime?;
    # A container for information about the source of a change
    ChangeSourceInfo 'source?;
    # Information about an error during a plan attempt
    ClusterPlanAttemptError 'error?;
    # The plan for the Kibana instance
    KibanaClusterPlan plan?;
    @jsondata:Name {value: "plan_attempt_log"}
    ClusterPlanStepInfo[] planAttemptLog;
    # If this plan is not current or pending, when the plan was no longer active (ISO format in UTC)
    @jsondata:Name {value: "plan_end_time"}
    string planEndTime?;
    # A UUID for each plan attempt
    @jsondata:Name {value: "plan_attempt_id"}
    string planAttemptId?;
    # A human readable name for each plan attempt, only populated when retrieving plan histories
    @jsondata:Name {value: "plan_attempt_name"}
    string planAttemptName?;
    # When this plan attempt (ie to apply the plan to the cluster) started (ISO format in UTC)
    @jsondata:Name {value: "attempt_start_time"}
    string attemptStartTime?;
};

# A collection of Organizations
public type OrganizationList record {
    # A cursor to get the next page of results
    @jsondata:Name {value: "next_page"}
    string nextPage?;
    # The list of organizations
    Organization[] organizations;
};

# The trust relationship with the clusters of one account
public type AccountTrustRelationship record {
    # the ID of the Account
    @jsondata:Name {value: "account_id"}
    string accountId;
    # If true, all clusters in this account will by default be trusted and the `trust_allowlist` is ignored
    @jsondata:Name {value: "trust_all"}
    boolean trustAll;
    # A human readable name of the trust relationship
    string name?;
    # The list of clusters to trust. Only used when `trust_all` is false
    @jsondata:Name {value: "trust_allowlist"}
    string[] trustAllowlist?;
};

# The list of resources used as remote clusters
public type RemoteResources record {
    # The remote resources
    RemoteResourceRef[] resources;
};

# Represents the Queries record for the operation: get-costs-items-by-deployment
public type GetCostsItemsByDeploymentQueries record {
    # A datetime for the beginning of the desired range for which to fetch costs. Defaults to start of current month
    string 'from?;
    # A datetime for the end of the desired range for which to fetch costs. Defaults to the current date
    string to?;
};

# The rule detail for a traffic filter egress rule
public type TrafficFilterEgressRule record {
    # The target protocol for an egress rule
    "all"|"tcp"|"udp" protocol;
    # A list of target ports for an egress rule
    int:Signed32[] ports?;
    # Allowed traffic filter egress target: IP address or CIDR mask
    string target;
};

# A response returned from the Deployment Resource endpoints
public type DeploymentResourceCrudResponse record {
    # The reference id of the resource
    @jsondata:Name {value: "ref_id"}
    string refId;
    # The kind of the stateless resource
    string kind;
    # The id of the deployment
    string id;
};

# The plan for the Elasticsearch cluster
public type ElasticsearchClusterPlan record {
    # The Elasticsearch cluster settings. When specified at the top level, provides a field-by-field default. When specified at the topology level, provides the override settings
    ElasticsearchConfiguration elasticsearch;
    # Defines the configuration parameters that control how the plan is applied. For example, the Elasticsearch cluster topology and Elasticsearch settings
    TransientElasticsearchPlanConfiguration transient?;
    # Enable autoscaling for this Elasticsearch cluster
    @jsondata:Name {value: "autoscaling_enabled"}
    boolean autoscalingEnabled?;
    @jsondata:Name {value: "cluster_topology"}
    ElasticsearchClusterTopologyElement[] clusterTopology;
    @jsondata:Name {value: "deployment_template"}
    DeploymentTemplateReference deploymentTemplate?;
};

# Represents the Queries record for the operation: restart-deployment-es-resource
public type RestartDeploymentEsResourceQueries record {
    # When set to true and restoring from shutdown, then will restore the cluster from the last snapshot (if available)
    @http:Query {name: "restore_snapshot"}
    boolean restoreSnapshot = true;
    # If true, cancels any pending plans before restarting. If false and there are pending plans, returns an error
    @http:Query {name: "cancel_pending"}
    boolean cancelPending = false;
    # The time, in seconds, to wait for shards that show no progress of initializing, before rolling the next group (default: 10 minutes)
    @http:Query {name: "shard_init_wait_time"}
    int shardInitWaitTime = 600;
    # If true, will not take a snapshot of the cluster before restarting
    @http:Query {name: "skip_snapshot"}
    boolean skipSnapshot = true;
    # Indicates the property or properties used to divide the list of instances to restart in groups. Valid options are: '\_\_all\_\_' (restart all at once), '\_\_zone\_\_' by logical zone, '\_\_name\_\_' one instance at a time, or a comma-separated list of attributes of the instances
    @http:Query {name: "group_attribute"}
    string groupAttribute = "__zone__";
};

# Information about a warning from a plan
public type ClusterPlanWarning record {
    # A unique warning code
    string code;
    # A description of the warning
    string message;
    # The ID of the step which produced a warning, if any
    @jsondata:Name {value: "step_id"}
    string stepId?;
};

# Represents the Headers record for the operation: get-costs-items-by-deployment
public type GetCostsItemsByDeploymentHeaders record {
    # Determines the response body format. Can be either application/json or text/csv
    @http:Header {name: "Accept"}
    string accept?;
};

# Additional configuration for the new deployment object
public type DeploymentCreateSettings record {
    # An optional string that declares the deployment's expected application. Example supported values are: elasticsearch, observability, security
    @jsondata:Name {value: "solution_type"}
    string solutionType?;
    # Enable autoscaling for this deployment
    @jsondata:Name {value: "autoscaling_enabled"}
    boolean autoscalingEnabled?;
    @jsondata:Name {value: "traffic_filter_settings"}
    TrafficFilterSettings trafficFilterSettings?;
    # The observability settings for a deployment
    DeploymentObservabilitySettings observability?;
};

# The costs associated to a Data Transfer and Storage (DTS) dimension for an organization. All of the costs, credits, and trials are expressed in Elastic Consumption Units (ECU)
public type DtsDimensionCosts record {
    # Costs associated to the Data Transfer and Storage (DTS) dimensions for an organization
    decimal cost;
    # DTS quantity
    DtsQuantity quantity;
    # DTS Rate
    DtsRate rate;
    # DTS dimension name
    string name;
    # DTS dimension Stock Keeping Unit (SKU)
    string sku;
    # Type of the DTS dimension usage
    string 'type;
};

# The specification for traffic filter ruleset
public type TrafficFilterRulesetRequest record {
    # Should the ruleset be automatically included in the new deployments
    @jsondata:Name {value: "include_by_default"}
    boolean includeByDefault;
    # Name of the ruleset
    string name;
    # Description of the ruleset
    string description?;
    # List of rules
    TrafficFilterRule[] rules;
    # Type of the ruleset
    string 'type;
    # The ruleset can be attached only to deployments in the specific region
    string region;
};

# > WARNING
# > This endpoint is deprecated and scheduled to be removed in the next major version. Use `cluster_blocking_issues` instead
# 
# Issues that prevent the Elasticsearch cluster or index from operating correctly
public type ElasticsearchClusterBlockingIssues record {
    # A list of issues that affect availability of the cluster's indices
    @jsondata:Name {value: "index_level"}
    ElasticsearchClusterBlockingIssueElement[] indexLevel;
    # A list of issues that affect availability of entire cluster
    @jsondata:Name {value: "cluster_level"}
    ElasticsearchClusterBlockingIssueElement[] clusterLevel;
    # Whether the cluster has issues (false) or not (true)
    boolean healthy;
};

# The snapshot configuration settings for an Elasticsearch cluster
public type ClusterSnapshotSettings record {
    # When set to true, the deployment will have SLM enabled. Default value is true
    boolean slm?;
    # Cron expression indicating when should snapshots be taken. This can be enabled only if SLM is enabled for the deployment and 'interval' is not present
    @jsondata:Name {value: "cron_expression"}
    string cronExpression?;
    # Interval between snapshots, with the format 'length unit' (space is optional), where unit can be one of: d (day), h (hour), min (minute). Default is 30 minutes
    string interval?;
    # Information about the Elasticsearch cluster snapshot retention
    ClusterSnapshotRetention retention?;
};

# Restores a snapshot from a local or remote repository
public type RestoreSnapshotConfiguration record {
    # The name of the snapshot to restore. Use '\_\_latest_success\_\_' to get the most recent snapshot from the specified repository
    @jsondata:Name {value: "snapshot_name"}
    string snapshotName;
    @jsondata:Name {value: "repository_config"}
    RestoreSnapshotRepoConfiguration repositoryConfig?;
    @jsondata:Name {value: "restore_payload"}
    RestoreSnapshotApiConfiguration restorePayload?;
    # The restore strategy to use. Defaults to a full restore. Partial restore will attempt to restore unavailable indices only
    "partial"|"full"|"recovery" strategy?;
    # If specified, contains the name of the snapshot repository - else will default to the Elastic Cloud system repo ('found-snapshots')
    @jsondata:Name {value: "repository_name"}
    string repositoryName?;
    # If specified, contains the name of the source cluster id. Do not send this if you are sending repository_config
    @jsondata:Name {value: "source_cluster_id"}
    string sourceClusterId?;
};

# Response returned when a command is successfully issued against a given Deployment resource
public type DeploymentResourceCommandResponse record {
    # List of warnings generated from validating command
    ReplyWarning[] warnings?;
};

# The container for a set of traffic filter rules
public type TrafficFilterRulesetInfo record {
    # List of associations. Returned only when include_associations query parameter is true
    FilterAssociation[] associations?;
    # Should the ruleset be automatically included in the new deployments
    @jsondata:Name {value: "include_by_default"}
    boolean includeByDefault;
    # Name of the ruleset
    string name;
    # Description of the ruleset
    string description?;
    # List of rules
    TrafficFilterRule[] rules;
    # The ruleset ID
    string id;
    # Type of the ruleset
    string 'type;
    # The ruleset can be attached only to deployments in the specific region
    string region;
    # Total number of associations. This includes associations the user does not have permission to view.Returned only when include_associations query parameter is true
    @jsondata:Name {value: "total_associations"}
    int:Signed32 totalAssociations?;
};

# The observability settings for a deployment
public type DeploymentObservabilitySettings record {
    # The logging settings for a deployment
    DeploymentLoggingSettings logging?;
    # The metrics settings for a deployment
    DeploymentMetricsSettings metrics?;
};

# A response returned from the Deployment create endpoint
public type DeploymentCreateResponse record {
    # Describes the diagnostics for a given Deployment-modifying payload
    DeploymentDiagnostics diagnostics?;
    # Whether or not the deployment was freshly created
    boolean created;
    # The name of the deployment
    string name;
    # A user-defined deployment alias for user-friendly resource URLs
    string alias?;
    # List of created resources
    DeploymentResource[] resources;
    # The id of the deployment
    string id;
};

# Information about the Kibana instances associated with the Elasticsearch cluster
public type KibanaSubClusterInfo record {
    # The Kibana cluster Id
    @jsondata:Name {value: "kibana_id"}
    string kibanaId;
    # A map of application-specific operations (which map to 'operationId's in the Swagger API) to metadata about that operation
    record {|Hyperlink...;|} links?;
    # Whether the associated Kibana cluster is currently available
    boolean enabled;
};

# Describes a given Deployment
public type DeploymentGetResponse record {
    # Additional configuration about the current deployment object
    DeploymentSettings settings?;
    # Additional information about the current deployment object
    DeploymentMetadata metadata?;
    # Whether the deployment is overall healthy or not (one or more of the resource info subsections will have healthy: false)
    boolean healthy;
    # The name of this deployment
    string name;
    # A user-defined deployment alias for user-friendly resource URLs
    string alias?;
    # Describes a resource belonging to a Deployment
    DeploymentResources resources;
    # A randomly-generated id of this Deployment
    string id;
    # List of instance configurations used in the deployment
    @jsondata:Name {value: "instance_configurations"}
    InstanceConfigurationInfo[] instanceConfigurations?;
    # Observability information for a deployment
    DeploymentObservability observability?;
};

# The plan for the App Search cluster
public type AppSearchPlan record {
    # Defines configuration parameters that control how the plan (ie consisting of the cluster topology and AppSearch settings) is applied
    TransientAppSearchPlanConfiguration transient?;
    @jsondata:Name {value: "cluster_topology"}
    AppSearchTopologyElement[] clusterTopology?;
    AppSearchConfiguration appsearch;
};

# Holds diagnostics for resources that will be created
public type Creates record {
    # Diagnostics for Enterprise Search resources
    @jsondata:Name {value: "enterprise_search"}
    EnterpriseSearch[] enterpriseSearch?;
    # Diagnostics for Elasticsearch clusters
    Elasticsearch[] elasticsearch?;
    # Diagnostics for Kibanas
    Kibana[] kibana?;
    # Diagnostics for APMs
    Apm[] apm?;
    # Diagnostics for Integrations Server
    @jsondata:Name {value: "integrations_server"}
    IntegrationsServer[] integrationsServer?;
    # Diagnostics for AppSearches
    AppSearch[] appsearch?;
};

# Observability health issue
public type ObservabilityIssue record {
    # Severity of the health issue
    string severity;
    # A user-friendly description of the observability health issue
    string description;
};

# Represents the Queries record for the operation: get-deployment-apm-resource-info
public type GetDeploymentApmResourceInfoQueries record {
    # Whether to include with the current and pending plan information the attempt log - can be very large per cluster
    @http:Query {name: "show_plan_logs"}
    boolean showPlanLogs = false;
    # Whether to include the full current and pending plan information in the response - can be large per cluster
    @http:Query {name: "show_plans"}
    boolean showPlans = true;
    # Whether to include the full cluster metadata in the response - can be large per cluster and also include credentials
    @http:Query {name: "show_metadata"}
    boolean showMetadata = false;
    # Whether to show cluster settings in the response
    @http:Query {name: "show_settings"}
    boolean showSettings = false;
    # Whether to include with the current and pending plan information the plan history- can be very large per cluster
    @http:Query {name: "show_plan_history"}
    boolean showPlanHistory = false;
    # If showing plans, whether to show values that are left at their default value (less readable but more informative)
    @http:Query {name: "show_plan_defaults"}
    boolean showPlanDefaults = false;
    # If set (defaults to false) then removes the transient section from all child resources, making it safe to reapply via an update
    @http:Query {name: "clear_transient"}
    boolean clearTransient = false;
};

# The structure that defines the routing settings for index curation
public type ElasticsearchCuration record {
    # The source instance configuration
    @jsondata:Name {value: "from_instance_configuration_id"}
    string fromInstanceConfigurationId;
    # The destination instance configuration
    @jsondata:Name {value: "to_instance_configuration_id"}
    string toInstanceConfigurationId;
};

# Chart Item
public type ChartItem record {
    # the collection of values to plot the chart item
    ChartItemValue[] values;
    # Axis X position
    int timestamp;
};

# An x509 certificate used by a DirectTrustRelationship
public type TrustedCertificate record {
    # The certificate MetaData
    CertificateMetaData metadata?;
    # The public ca certificate as string in PEM format
    string pem;
};

# The contents of the Elasticsearch keystore
public type KeystoreContents record {
    # List of secrets
    record {|KeystoreSecret...;|} secrets;
};

# A strategy that creates instances with the new plan, migrates data from the old instances, then shuts down the old instances. `GrowShrinkStrategyConfig` is safer than 'rolling' and ensures single node availability during a plan change, but can be a lot slower on larger clusters
public type GrowShrinkStrategyConfig record {
};

# The log message from a specified stage of an executed step in a plan
public type ClusterPlanStepLogMessageInfo record {
    # Stage that info log message takes place in
    "starting"|"completed"|"in_progress" stage;
    # The failure type, in case the step failed
    @jsondata:Name {value: "failure_type"}
    string failureType?;
    # Time in milliseconds since previous log message
    @jsondata:Name {value: "delta_in_millis"}
    int deltaInMillis?;
    # A map with details for the log about what happened during the step execution. Keys and values for are always both strings, representing the name of the detail and its value, respectively
    record {|string...;|} details;
    # Human readable log message
    string message;
    # Timestamp marking on info log of step
    string timestamp;
};

# A query that matches nested objects
public type NestedQuery record {
    # The path to the nested object
    string path;
    # Allows to specify how inner children matching affects score of the parent. Refer to the Elasticsearch documentation for details
    @jsondata:Name {value: "score_mode"}
    "avg"|"sum"|"min"|"max"|"none" scoreMode?;
    # The container for all of the allowed Elasticsearch queries. Specify only one property each time
    QueryContainer query;
};

# Represents the Queries record for the operation: cancel-deployment-resource-pending-plan
public type CancelDeploymentResourcePendingPlanQueries record {
    # When `true`, deletes the pending plan instead of attempting a graceful cancellation. The default is `false`
    @http:Query {name: "force_delete"}
    boolean forceDelete = false;
    # When `true`, returns successfully, even when plans are missing. The default is `false`
    @http:Query {name: "ignore_missing"}
    boolean ignoreMissing = false;
};

# Contains a list of Deployments as result of a search request
public type DeploymentsSearchResponse record {
    @jsondata:Name {value: "minimal_metadata"}
    record {}[] minimalMetadata?;
    # To retrieve the next batch of deployments from this search, specify this value in the cursor field of the next search request. For paginated searches, it is recommended to sort on a static and unique field, like deployment or cluster id. A static and unique sort avoids concurrent updates causing a deployment to move across pages and becoming a duplicate or lost entry. The default sort of rank and modified date is often good for getting a particular deployment into the first page, but if a not yet seen deployment is modified in between page requests, then it would be left out from the next page
    string cursor?;
    DeploymentSearchResponse[] deployments;
    # If a query is supplied, then the total number of deployments that matched
    @jsondata:Name {value: "match_count"}
    int:Signed32 matchCount?;
    # The number of deployments actually returned, either as deployment instances or as minimalMetadata objects
    @jsondata:Name {value: "return_count"}
    int:Signed32 returnCount;
};

# Information about current, pending, and past Enterprise Search Server plans
public type EnterpriseSearchPlansInfo record {
    # Information about the Enterprise Search Server plan
    EnterpriseSearchPlanInfo current?;
    # Whether the plan situation is healthy (if unhealthy, means the last plan attempt failed)
    boolean healthy;
    # Information about the Enterprise Search Server plan
    EnterpriseSearchPlanInfo pending?;
    EnterpriseSearchPlanInfo[] history;
};

# The overview information for the Integrations Server
public type IntegrationsServerInfo record {
    # The settings for the Integrations Server
    IntegrationsServerSettings settings?;
    # Information about the public and internal state, and the configuration settings of an Elasticsearch cluster
    ClusterMetadataInfo metadata?;
    # The topology for Elasticsearch clusters, multiple Kibana instances, or multiple APM Servers. The `ClusterTopologyInfo` also includes the instances and containers, and where they are located
    ClusterTopologyInfo topology;
    @jsondata:Name {value: "plan_info"}
    IntegrationsServerPlansInfo planInfo;
    @jsondata:Name {value: "elasticsearch_cluster"}
    TargetElasticsearchCluster elasticsearchCluster;
    # Whether the Integrations Server is healthy or not (one or more of the info subsections will have healthy: false)
    boolean healthy;
    # External resources related to the Integrations Server
    @jsondata:Name {value: "external_links"}
    ExternalHyperlink[] externalLinks;
    # The name of the Integrations Server
    string name;
    # The mode APM is operating in
    @jsondata:Name {value: "apm_server_mode"}
    "standalone"|"managed" apmServerMode?;
    # A map of application-specific operations (which map to 'operationId's in the Swagger API) to metadata about that operation
    record {|Hyperlink...;|} links?;
    # The id of the Integrations Server
    string id;
    # The id of the deployment that this Integrations Server belongs to
    @jsondata:Name {value: "deployment_id"}
    string deploymentId?;
    # The region that this Integrations Server belongs to. Only populated in SaaS or federated ECE
    string region?;
    # Integrations Server status
    "initializing"|"stopping"|"stopped"|"rebooting"|"restarting"|"reconfiguring"|"started" status;
};

# Represents the Queries record for the operation: shutdown-deployment-es-resource
public type ShutdownDeploymentEsResourceQueries record {
    # Hide cluster on shutdown. Hidden clusters are not listed by default. Only applicable for Platform administrators
    boolean hide?;
    # If true, will skip taking a snapshot of the cluster before shutting the cluster down (if even possible)
    @http:Query {name: "skip_snapshot"}
    boolean skipSnapshot = false;
};

# Defines the configuration parameters that control how the plan is applied. For example, the Elasticsearch cluster topology and Elasticsearch settings
public type TransientElasticsearchPlanConfiguration record {
    @jsondata:Name {value: "plan_configuration"}
    ElasticsearchPlanControlConfiguration planConfiguration?;
    # If specified, contains transient settings to be applied to an Elasticsearch cluster during changes,default values shown below applied.
    # These can be overridden by specifying them in the map (or null to unset). Additional settings can also be set. Settings will be cleared after the plan has finished. If not specified, no settings will be applied.
    # NOTE: These settings are only explicitly cleared for 5.x+ clusters, they must be hand-reset to their defaults in 2.x- (or a cluster reboot will clear them).
    # - indices.store.throttle.max_bytes_per_sec: 120Mb
    # - indices.recovery.max_bytes_per_sec: 120Mb
    # - cluster.routing.allocation.cluster_concurrent_rebalance: 5
    # - cluster.routing.allocation.node_initial_primaries_recoveries: 5
    # - cluster.routing.allocation.node_concurrent_incoming_recoveries: 5
    # For version 8.1 and later no defaults are provided through this mechanism, but instead hardware dependent settings are provided to each instance
    @jsondata:Name {value: "cluster_settings_json"}
    record {} clusterSettingsJson?;
    @jsondata:Name {value: "restore_snapshot"}
    RestoreSnapshotConfiguration restoreSnapshot?;
    # The options for performing a plan change. Specify only one property each time. The default is `grow_and_shrink`
    PlanStrategy strategy?;
    @jsondata:Name {value: "remote_clusters"}
    RemoteResources remoteClusters?;
};

# The query that matches documents with fields that contain terms within a specified range
public type RangeQuery record {
    # Less-than
    record {} lt?;
    # Formatted dates will be parsed using the format specified on the date field by default, but it can be overridden by passing the format parameter
    string format?;
    # Greater-than or equal to
    record {} gte?;
    # An optional boost value to apply to the query
    float boost?;
    # Less-than or equal to
    record {} lte?;
    # Dates can be converted from another timezone to UTC either by specifying the time zone in the date value itself (if the format accepts it), or it can be specified as the time_zone parameter
    @jsondata:Name {value: "time_zone"}
    string timeZone?;
    # Greater-than
    record {} gt?;
};

# The options for performing a plan change. Specify only one property each time. The default is `grow_and_shrink`
public type PlanStrategy record {
    # Performs inline, rolling configuration changes that mutate existing containers. TIP: This is the fastest way to update a plan, but can fail for complex plan changes, such as topology changes. Also, this is less safe for configuration changes that leave a cluster in a non running state. NOTE: When you perform a major version upgrade, and 'group_by' is set to 'pass:macros[__all__]';, rolling is required
    RollingStrategyConfig rolling?;
    # A strategy that lets constructor choose the most optimal way to execute the plan
    AutodetectStrategyConfig autodetect?;
    @jsondata:Name {value: "rolling_grow_and_shrink"}
    RollingGrowShrinkStrategyConfig rollingGrowAndShrink?;
    @jsondata:Name {value: "grow_and_shrink"}
    GrowShrinkStrategyConfig growAndShrink?;
};

# An APM creation request paired with the alias of the Elasticsearch cluster it should be paired with
public type ApmPayload record {
    # A locally-unique user-specified id for APM
    @jsondata:Name {value: "ref_id"}
    string refId;
    # The settings for the APM Server
    ApmSettings settings?;
    # Alias to the Elasticsearch Cluster to attach APM to
    @jsondata:Name {value: "elasticsearch_cluster_ref_id"}
    string elasticsearchClusterRefId;
    # The human readable name for the APM cluster (default: takes the name of its Elasticsearch cluster)
    @jsondata:Name {value: "display_name"}
    string displayName?;
    # The region where this resource exists
    string region;
    # The plan for the APM Server
    ApmPlan plan;
};

# Information about the APM Servers associated with the Elasticsearch cluster
public type ApmSubInfo record {
    # A map of application-specific operations (which map to 'operationId's in the Swagger API) to metadata about that operation
    record {|Hyperlink...;|} links?;
    # Whether the associated APM cluster is currently available
    boolean enabled;
    # The APM cluster Id
    @jsondata:Name {value: "apm_id"}
    string apmId;
};

# The overview information for the APM Server
public type ApmInfo record {
    # The settings for the APM Server
    ApmSettings settings?;
    # Information about the public and internal state, and the configuration settings of an Elasticsearch cluster
    ClusterMetadataInfo metadata?;
    # The topology for Elasticsearch clusters, multiple Kibana instances, or multiple APM Servers. The `ClusterTopologyInfo` also includes the instances and containers, and where they are located
    ClusterTopologyInfo topology;
    @jsondata:Name {value: "plan_info"}
    ApmPlansInfo planInfo;
    @jsondata:Name {value: "elasticsearch_cluster"}
    TargetElasticsearchCluster elasticsearchCluster;
    # Whether the APM is healthy or not (one or more of the info subsections will have healthy: false)
    boolean healthy;
    # External resources related to the APM
    @jsondata:Name {value: "external_links"}
    ExternalHyperlink[] externalLinks;
    # The name of the APM
    string name;
    # The mode APM is operating in
    @jsondata:Name {value: "apm_server_mode"}
    "standalone"|"managed" apmServerMode?;
    # A map of application-specific operations (which map to 'operationId's in the Swagger API) to metadata about that operation
    record {|Hyperlink...;|} links?;
    # The id of the APM
    string id;
    # The id of the deployment that this APM Server belongs to
    @jsondata:Name {value: "deployment_id"}
    string deploymentId?;
    # The region that this APM belongs to. Only populated in SaaS or federated ECE
    string region?;
    # APM status
    "initializing"|"stopping"|"stopped"|"rebooting"|"restarting"|"reconfiguring"|"started" status;
};

# Information about the unavailable replicas. NOTE: Unlike shards, unavailable replicas indicate a loss of redundancy rather than a loss of availability
public type ElasticsearchReplicaElement record {
    # The Elastic Cloud name/id of the instance (container)
    @jsondata:Name {value: "instance_name"}
    string instanceName;
    # The number of unavailable replicas on this instance
    @jsondata:Name {value: "replica_count"}
    int:Signed32 replicaCount;
};

# The settings for multiple Kibana instances
public type KibanaClusterSettings record {
    # The top-level configuration settings for the Elasticsearch cluster
    ClusterMetadataSettings metadata?;
};

# Describes the Deployment resource updates
public type DeploymentUpdateResources record {
    # A list of payloads for Enterprise Search updates
    @jsondata:Name {value: "enterprise_search"}
    EnterpriseSearchPayload[] enterpriseSearch?;
    # A list of payloads for Elasticsearch cluster updates
    ElasticsearchPayload[] elasticsearch?;
    # A list of payloads for Kibana updates
    KibanaPayload[] kibana?;
    # A list of payloads for APM updates
    ApmPayload[] apm?;
    # A list of payloads for AppSearch updates. AppSearch has been replaced by Enterprise Search in the Elastic Stack 7.7 and higher
    AppSearchPayload[] appsearch?;
    # A list of payloads for Integrations Server updates
    @jsondata:Name {value: "integrations_server"}
    IntegrationsServerPayload[] integrationsServer?;
};

# The certificate MetaData
public type CertificateMetaData record {
    # The expiry date of the certificate in UTC
    @jsondata:Name {value: "valid_to"}
    string validTo;
    # The fingerprint of the certificate
    string fingerprint;
    # The valid from date of the certificate in UTC
    @jsondata:Name {value: "valid_from"}
    string validFrom;
    # Other deployments also trusting this certificate
    @jsondata:Name {value: "also_trusted_by"}
    string[] alsoTrustedBy?;
};

# Describes the resources that will belong to a Deployment
public type DeploymentCreateResources record {
    # A list of payloads for Enterprise Search creation
    @jsondata:Name {value: "enterprise_search"}
    EnterpriseSearchPayload[] enterpriseSearch?;
    # A list of payloads for Elasticsearch cluster creation
    ElasticsearchPayload[] elasticsearch?;
    # A list of payloads for Kibana creation
    KibanaPayload[] kibana?;
    # A list of payloads for APM creation. WARNING: For stack versions 8.0.0 and higher the integrations_server payload should be used instead, as this field becomes deprecated
    ApmPayload[] apm?;
    # A list of payloads for AppSearch updates. AppSearch has been replaced by Enterprise Search in the Elastic Stack 7.7 and higher
    AppSearchPayload[] appsearch?;
    # A list of payloads for Integrations Server creation
    @jsondata:Name {value: "integrations_server"}
    IntegrationsServerPayload[] integrationsServer?;
};

# A request for creating a new Deployment consisting of multiple clusters
public type DeploymentCreateRequest record {
    # Additional configuration for the new deployment object
    DeploymentCreateSettings settings?;
    # Additional information about the new deployment object
    DeploymentCreateMetadata metadata?;
    # A name for the deployment; otherwise this will be the generated deployment id
    string name?;
    # Describes the resources that will belong to a Deployment
    DeploymentCreateResources resources?;
    # A user-defined alias to use in place of Cluster IDs for user-friendly URLs
    string alias?;
    # Identifier of the region to be used as the default for all the resources of the deployment
    string region?;
    # The version for all the resources of the deployment (must be one of the supported versions). Defaults to the latest version if not specified
    string version?;
};

public type Hyperlink record {
    # Whether the operation requires elevated permissions (when the field is present, elevated permissions are required)
    @jsondata:Name {value: "need_elevated_permissions"}
    boolean needElevatedPermissions?;
};

# Costs associated to a set of deployments for an organization. All of the costs are expressed in Elastic Consumption Unit (ECU)
public type DeploymentsCosts record {
    # Costs of the list of deployments
    DeploymentCosts[] deployments;
    # Total cost for all deployments
    @jsondata:Name {value: "total_cost"}
    decimal totalCost;
};

# Additional information about the current deployment object
public type DeploymentMetadata record {
    # Indicates if the Deployment is BYOK enabled or not
    @jsondata:Name {value: "byok_enabled"}
    boolean byokEnabled?;
    # Arbitrary user-defined metadata associated with this deployment
    MetadataItem[] tags?;
};

# The configuration template for Elasticsearch instances, Kibana instances, and APM Servers
public type InstanceConfigurationInfo record {
    # Node types (master, data) for the instance. For instance configurations where the type (and tier) is specified in the 'id', the default value of 'node_types' will be automatically inferred
    @jsondata:Name {value: "node_types"}
    string[] nodeTypes?;
    # Optional arbitrary metadata to associate with this template
    record {} metadata?;
    # The maximum number of availability zones in which this instance configuration has allocators. This field will be missing unless explicitly requested with the show_max_zones parameter
    @jsondata:Name {value: "max_zones"}
    int:Signed32 maxZones?;
    # Settings for the instance CPU multiplier
    @jsondata:Name {value: "cpu_multiplier"}
    decimal cpuMultiplier?;
    # Settings for the instance storage multiplier
    @jsondata:Name {value: "storage_multiplier"}
    decimal storageMultiplier?;
    # Display name for the instance configuration
    string name;
    # Optional description for the instance configuration
    string description?;
    # Unique identifier for the instance configuration
    string id?;
    # The type of instance. For instance configurations where the type is specified in the 'id', the default value of 'instance_type' will be automatically inferred
    @jsondata:Name {value: "instance_type"}
    "elasticsearch"|"kibana"|"apm"|"integrations_server"|"appsearch"|"enterprise_search" instanceType?;
    # If the IC is configuration controlled, this field is the version either being read back (reads return the latest IC unless specified by the 'config_version' URL param), or the version to update. Cannot be used in creates. For unversioned IC reads it is left empty
    @jsondata:Name {value: "config_version"}
    int:Signed32 configVersion?;
    @jsondata:Name {value: "discrete_sizes"}
    DiscreteSizes discreteSizes;
};

# Performs inline, rolling configuration changes that mutate existing containers. TIP: This is the fastest way to update a plan, but can fail for complex plan changes, such as topology changes. Also, this is less safe for configuration changes that leave a cluster in a non running state. NOTE: When you perform a major version upgrade, and 'group_by' is set to 'pass:macros[__all__]';, rolling is required
public type RollingStrategyConfig record {
    # Whether to skip attempting to do a synced flush on the filesystem of the container (default: false), which is less safe but may be required if the container is unhealthy
    @jsondata:Name {value: "skip_synced_flush"}
    boolean skipSyncedFlush?;
    # Specifies the grouping attribute to use when rolling several instances. Instances that share the same value for the provided attribute key are rolled together as a unit. Examples that make sense to use are '\_\_all\_\_' (roll all instances as a single unit), 'logical_zone_name' (roll instances by zone), '\_\_name\_\_' (roll one instance at a time, the default if not specified). Note that '\_\_all\_\_' is required when performing a major version upgrade
    @jsondata:Name {value: "group_by"}
    string groupBy?;
    # Whether we allow changing the capacity of instances (default false). This is currently implemented by stopping, re-creating then starting the affected instance on its associated allocator when performing the changes. NOTES: This requires a round-trip through the allocation infrastructure of the active constructor, as it has to reserve the target capacity without over-committing
    @jsondata:Name {value: "allow_inline_resize"}
    boolean allowInlineResize?;
    # The time, in seconds, to wait for shards that show no progress of initializing before rolling the next group (default: 10 minutes)
    @jsondata:Name {value: "shard_init_wait_time"}
    int shardInitWaitTime?;
};

# The topology for Elasticsearch clusters, multiple Kibana instances, or multiple APM Servers. The `ClusterTopologyInfo` also includes the instances and containers, and where they are located
public type ClusterTopologyInfo record {
    ClusterInstanceInfo[] instances;
    # Whether the cluster topology is healthy (ie all instances are started and the services they run - ie elasticsearch - are available
    boolean healthy;
};

public type EnterpriseSearchConfiguration record {
    # An arbitrary JSON object allowing (non-admin) cluster owners to set their parameters (only one of this and 'user_settings_yaml' is allowed), provided the parameters are on the allowlist and not on the denylist. (This field together with 'user_settings_override*' and 'system_settings' defines the total set of Enterprise Search settings)
    @jsondata:Name {value: "user_settings_json"}
    record {} userSettingsJson?;
    @jsondata:Name {value: "system_settings"}
    EnterpriseSearchSystemSettings systemSettings?;
    # An arbitrary YAML object allowing (non-admin) cluster owners to set their parameters (only one of this and 'user_settings_json' is allowed), provided the parameters are on the allowlist and not on the denylist. (This field together with 'user_settings_override*' and 'system_settings' defines the total set of Enterprise Search settings)
    @jsondata:Name {value: "user_settings_yaml"}
    string userSettingsYaml?;
    # An arbitrary JSON object allowing ECE admins to set clusters' parameters (only one of this and 'user_settings_override_yaml' is allowed), i.e. in addition to the documented 'system_settings'. (This field together with 'system_settings' and 'user_settings*' defines the total set of Enterprise Search settings)
    @jsondata:Name {value: "user_settings_override_json"}
    record {} userSettingsOverrideJson?;
    # The version of the Enterprise Search cluster (must be one of the ECE supported versions, and won't work unless it matches the Elasticsearch version. Leave blank to auto-detect version.)
    string version?;
    # A docker URI that allows overriding of the default docker image specified for this version
    @jsondata:Name {value: "docker_image"}
    string dockerImage?;
    # An arbitrary YAML object allowing ECE admins to set clusters' parameters (only one of this and 'user_settings_override_json' is allowed), i.e. in addition to the documented 'system_settings'. (This field together with 'system_settings' and 'user_settings*' defines the total set of Enterprise Search settings)
    @jsondata:Name {value: "user_settings_override_yaml"}
    string userSettingsOverrideYaml?;
};

# Information about the current, pending, or past Kibana instance plans
public type KibanaClusterPlansInfo record {
    # Information about the current, pending, or past Kibana instance plan
    KibanaClusterPlanInfo current?;
    # Whether the plan situation is healthy (if unhealthy, means the last plan attempt failed)
    boolean healthy;
    # Information about the current, pending, or past Kibana instance plan
    KibanaClusterPlanInfo pending?;
    KibanaClusterPlanInfo[] history;
};

# Information about an error during a plan attempt
public type ClusterPlanAttemptError record {
    # The failure type
    @jsondata:Name {value: "failure_type"}
    string failureType?;
    # A map with details regarding the error. Both the keys and values are always strings, representing the name of the detail and its value, respectively
    record {|string...;|} details;
    # Human readable error message
    string message;
    # Timestamp marking on info log of step
    string timestamp;
};

# All user memberships to an organization
public type OrganizationMemberships record {
    # The list of organization memberships
    OrganizationMembership[] members;
};

# The configuration options for the Integrations Server
public type IntegrationsServerConfiguration record {
    # The mode the Integrations Server is operating in
    "standalone"|"managed" mode?;
    # An arbitrary JSON object allowing (non-admin) cluster owners to set their parameters (only one of this and 'user_settings_yaml' is allowed), provided the parameters are on the allowlist and not on the denylist. (This field together with 'user_settings_override*' and 'system_settings' defines the total set of Integrations Server settings)
    @jsondata:Name {value: "user_settings_json"}
    record {} userSettingsJson?;
    @jsondata:Name {value: "system_settings"}
    IntegrationsServerSystemSettings systemSettings?;
    # An arbitrary YAML object allowing (non-admin) cluster owners to set their parameters (only one of this and 'user_settings_json' is allowed), provided the parameters are on the allowlist and not on the denylist. (These field together with 'user_settings_override*' and 'system_settings' defines the total set of Integrations Server settings)
    @jsondata:Name {value: "user_settings_yaml"}
    string userSettingsYaml?;
    # An arbitrary JSON object allowing ECE admins owners to set clusters' parameters (only one of this and 'user_settings_override_yaml' is allowed), ie in addition to the documented 'system_settings'. (This field together with 'system_settings' and 'user_settings*' defines the total set of Integrations Server settings)
    @jsondata:Name {value: "user_settings_override_json"}
    record {} userSettingsOverrideJson?;
    # The version of the Integrations Server cluster (must be one of the ECE supported versions, and won't work unless it matches the Integrations Server version. Leave blank to auto-detect version.)
    string version?;
    # A docker URI that allows overriding of the default docker image specified for this version
    @jsondata:Name {value: "docker_image"}
    string dockerImage?;
    # An arbitrary YAML object allowing ECE admins owners to set clusters' parameters (only one of this and 'user_settings_override_json' is allowed), ie in addition to the documented 'system_settings'. (This field together with 'system_settings' and 'user_settings*' defines the total set of Integrations Server settings)
    @jsondata:Name {value: "user_settings_override_yaml"}
    string userSettingsOverrideYaml?;
};

# Describes a resource belonging to a Deployment
public type DeploymentResources record {
    # List of Enterprise Search resources in your Deployment
    @jsondata:Name {value: "enterprise_search"}
    EnterpriseSearchResourceInfo[] enterpriseSearch;
    # List of Elasticsearch resources in your Deployment
    ElasticsearchResourceInfo[] elasticsearch;
    # List of Kibana resources in your Deployment
    KibanaResourceInfo[] kibana;
    # List of Apm resources in your Deployment
    ApmResourceInfo[] apm;
    # List of App Search resources in your Deployment
    AppSearchResourceInfo[] appsearch;
    # List of Integrations Server resources in your Deployment
    @jsondata:Name {value: "integrations_server"}
    IntegrationsServerResourceInfo[] integrationsServer;
};

# Embedded object that contains information for linking into a specific Kibana page configured via the template
public type KibanaDeeplink record {
    # Semver condition when to apply the URI
    string semver;
    # URI to which the user should be directed
    string uri;
};

# Represents the Queries record for the operation: get-deployment-enterprise-search-resource-info
public type GetDeploymentEnterpriseSearchResourceInfoQueries record {
    # Whether to include with the current and pending plan information the attempt log - can be very large per cluster
    @http:Query {name: "show_plan_logs"}
    boolean showPlanLogs = false;
    # Whether to include the full current and pending plan information in the response - can be large per cluster
    @http:Query {name: "show_plans"}
    boolean showPlans = true;
    # Whether to include the full cluster metadata in the response - can be large per cluster and also include credentials
    @http:Query {name: "show_metadata"}
    boolean showMetadata = false;
    # Whether to show cluster settings in the response
    @http:Query {name: "show_settings"}
    boolean showSettings = false;
    # Whether to include with the current and pending plan information the plan history- can be very large per cluster
    @http:Query {name: "show_plan_history"}
    boolean showPlanHistory = false;
    # If showing plans, whether to show values that are left at their default value (less readable but more informative)
    @http:Query {name: "show_plan_defaults"}
    boolean showPlanDefaults = false;
    # If set (defaults to false) then removes the transient section from all child resources, making it safe to reapply via an update
    @http:Query {name: "clear_transient"}
    boolean clearTransient = false;
};

# Detailed costs associated to an Elastic Cloud Resource for an organization. All of the costs are expressed in Elastic Consumption Unit (ECU)
public type ItemCosts record {
    # Resource usage in hours
    int hours;
    # Period
    Period period;
    # Kind of resource
    "elasticsearch"|"kibana"|"apm"|"integrations_server"|"appsearch"|"enterprise_search" kind;
    # Resource price
    decimal price;
    # Price per hour
    @jsondata:Name {value: "price_per_hour"}
    decimal pricePerHour;
    # Resource name
    string name;
    # Stock Keeping Unit (SKU)
    string sku;
    # Number of instances
    @jsondata:Name {value: "instance_count"}
    int:Signed32 instanceCount;
};

# Configuration of trust with other clusters
public type ElasticsearchClusterTrustSettings record {
    # The list of trust relationships with external entities
    ExternalTrustRelationship[] 'external?;
    # The list of trust relationships where the certificate is bundled with the trust setting. Allows configuring trust for clusters running outside of an Elastic Cloud managed environment or in an Elastic Cloud environment without an environment level trust established
    DirectTrustRelationship[] direct?;
    # The list of trust relationships with different accounts
    AccountTrustRelationship[] accounts?;
};

# A URL to access the service of a resource
public type ServiceUrl record {
    # Name of the service
    string 'service;
    # The full URL to access the service
    string url;
};

# Represents the Queries record for the operation: restart-deployment-stateless-resource
public type RestartDeploymentStatelessResourceQueries record {
    # If true, cancels any pending plans before restarting. If false and there are pending plans, returns an error
    @http:Query {name: "cancel_pending"}
    boolean cancelPending = false;
};

# Describes an Elasticsearch resource belonging to a Deployment
public type ElasticsearchResourceInfo record {
    # The locally-unique user-specified id of a Resource
    @jsondata:Name {value: "ref_id"}
    string refId;
    # The randomly-generated id of a Resource
    string id;
    # The region where this resource exists
    string region;
    # The information for an Elasticsearch cluster
    ElasticsearchClusterInfo info;
};

# Describes an Kibana resource belonging to a Deployment
public type KibanaResourceInfo record {
    # The locally-unique user-specified id of a Resource
    @jsondata:Name {value: "ref_id"}
    string refId;
    # The Elasticsearch cluster that this resource depends on
    @jsondata:Name {value: "elasticsearch_cluster_ref_id"}
    string elasticsearchClusterRefId;
    # The randomly-generated id of a Resource
    string id;
    # The region where this resource exists
    string region;
    # The top-level object information for a Kibana instance
    KibanaClusterInfo info;
};

# Describes an APM resource belonging to a Deployment
public type ApmResourceInfo record {
    # The locally-unique user-specified id of a Resource
    @jsondata:Name {value: "ref_id"}
    string refId;
    # The Elasticsearch cluster that this resource depends on
    @jsondata:Name {value: "elasticsearch_cluster_ref_id"}
    string elasticsearchClusterRefId;
    # The randomly-generated id of a Resource
    string id;
    # The region where this resource exists
    string region;
    # The overview information for the APM Server
    ApmInfo info;
};

# The association with a ruleset or user auth token for a deployment, template, or product
public type FilterAssociation record {
    # Type of the traffic filter ruleset association, such as 'deployment', 'cluster'
    @jsondata:Name {value: "entity_type"}
    string entityType;
    # ID of the entity, such as the deployment ID or Elasticsearch cluster ID
    string id;
};

# A response returned from the Deployment update endpoint
public type DeploymentUpdateResponse record {
    # Additional configuration about the current deployment object
    DeploymentSettings settings?;
    # Describes the diagnostics for a given Deployment-modifying payload
    DeploymentDiagnostics diagnostics?;
    @jsondata:Name {value: "shutdown_resources"}
    Orphaned shutdownResources?;
    # The name of the deployment
    string name;
    # A user-defined alias to use in place of ResourceIds for user-friendly resource URLs
    string alias?;
    # List of resources that are part of the deployment after the update operation
    DeploymentResource[] resources;
    # The id of the deployment
    string id;
};

# Represents the Queries record for the operation: get-costs-charts
public type GetCostsChartsQueries record {
    # The desired bucketing strategy for the charts. Defaults to `daily`
    @http:Query {name: "bucketing_strategy"}
    "daily"|"monthly" bucketingStrategy = "daily";
    # A datetime for the beginning of the desired range for which to fetch costs. Defaults to start of current month
    string 'from?;
    # A datetime for the end of the desired range for which to fetch costs. Defaults to the current date
    string to?;
};

public type RoleMappingRule record {
    # The rules that must match. All rules must match for the role assignment to be applied
    RoleMappingGroupRule[] all?;
    # The rules that must match. Only one rule must match for the role assignment to be applied
    RoleMappingGroupRule[] 'any?;
};

# Represents the Queries record for the operation: get-costs-deployments
public type GetCostsDeploymentsQueries record {
    # A datetime for the beginning of the desired range for which to fetch activity. Defaults to start of current month
    string 'from?;
    # A datetime for the end of the desired range for which to fetch activity. Defaults to the current date
    string to?;
};

# A strategy that lets constructor choose the most optimal way to execute the plan
public type AutodetectStrategyConfig record {
};

# An Enterprise Search creation request paired with the alias of the Elasticsearch cluster it should be paired with
public type EnterpriseSearchPayload record {
    # A locally-unique user-specified id for Enterprise Search
    @jsondata:Name {value: "ref_id"}
    string refId;
    # The settings for the Enterprise Search
    EnterpriseSearchSettings settings?;
    # Alias to the Elasticsearch Cluster to attach Enterprise Search to
    @jsondata:Name {value: "elasticsearch_cluster_ref_id"}
    string elasticsearchClusterRefId;
    # The human readable name for the Enterprise Search cluster (default: takes the name of its Elasticsearch cluster)
    @jsondata:Name {value: "display_name"}
    string displayName?;
    # The region where this resource exists
    string region;
    # The plan for the Enterprise Search cluster
    EnterpriseSearchPlan plan;
};

# The response model for the API keys
public type ApiKeysResponse record {
    # The list of API keys
    ApiKeyResponse[] keys;
};

# A collection of ChartItems
public type ChartItems record {
    # The list of chart item
    ChartItem[] data;
};

# The body of a request to create a new extension
public type CreateExtensionRequest record {
    # The extension name. Only ASCII alphanumeric and [_.-] characters allowed
    string name;
    # The URL to download the extension archive
    @jsondata:Name {value: "download_url"}
    string downloadUrl?;
    # The extension description
    string description?;
    # The extension type
    @jsondata:Name {value: "extension_type"}
    "plugin"|"bundle" extensionType;
    # The Elasticsearch version
    string version;
};

# The APM Server configuration for an Elastic Stack version
public type StackVersionApmConfig record {
    @jsondata:Name {value: "capacity_constraints"}
    StackVersionInstanceCapacityConstraint capacityConstraints?;
    # Settings that are applied to all nodes of this type
    record {} settings?;
    # Node types that are compatible with this one
    @jsondata:Name {value: "compatible_node_types"}
    string[] compatibleNodeTypes?;
    # List of configuration options that cannot be overridden by user settings
    string[] blacklist;
    # Version of APM
    string version?;
    # Docker image for the APM
    @jsondata:Name {value: "docker_image"}
    string dockerImage;
};

# Information about a system alert on an Elasticsearch cluster
public type ClusterSystemAlert record {
    # Instance that caused the system alert
    @jsondata:Name {value: "instance_name"}
    string instanceName;
    # The exit_code related to the event. Only applicable for alert_type: slain
    @jsondata:Name {value: "exit_code"}
    int:Signed32 exitCode?;
    # Type of system alert
    @jsondata:Name {value: "alert_type"}
    "automatic_restart"|"heap_dump"|"unknown_event" alertType;
    # The URL related to the event. Only applicable for alert_type: heap_dump
    string url?;
    # Timestamp marking the system alert
    string timestamp;
};

# Represents the Queries record for the operation: get-deployment-es-resource-info
public type GetDeploymentEsResourceInfoQueries record {
    # Number of system alerts (such as forced restarts due to memory limits) to be included in the response - can be large per cluster. Negative numbers or 0 will not return field
    @http:Query {name: "show_system_alerts"}
    int showSystemAlerts = 0;
    # Whether to include with the current and pending plan information the attempt log - can be very large per cluster
    @http:Query {name: "show_plan_logs"}
    boolean showPlanLogs = false;
    # Whether to include the full current and pending plan information in the response - can be large per cluster
    @http:Query {name: "show_plans"}
    boolean showPlans = true;
    # Whether to include the full cluster metadata in the response - can be large per cluster and also include credentials
    @http:Query {name: "show_metadata"}
    boolean showMetadata = false;
    # If showing plans, whether to leave pre-2.0.0 plans in their legacy format (the default), or whether to update them to 2.0.x+ format (if 'true')
    @http:Query {name: "convert_legacy_plans"}
    boolean convertLegacyPlans = false;
    # Whether to include the Elasticsearch 2.x security information in the response - can be large per cluster and also include credentials
    @http:Query {name: "show_security"}
    boolean showSecurity = false;
    # Whether to show cluster settings in the response
    @http:Query {name: "show_settings"}
    boolean showSettings = false;
    # Whether to include with the current and pending plan information the plan history- can be very large per cluster
    @http:Query {name: "show_plan_history"}
    boolean showPlanHistory = false;
    # If showing plans, whether to show values that are left at their default value (less readable but more informative)
    @http:Query {name: "show_plan_defaults"}
    boolean showPlanDefaults = false;
    # If set (defaults to false) then removes the transient section from all child resources, making it safe to reapply via an update
    @http:Query {name: "clear_transient"}
    boolean clearTransient = false;
    # If showing plans, whether to enrich the plan by including the missing elements from the deployment template it is based on
    @http:Query {name: "enrich_with_template"}
    boolean enrichWithTemplate = true;
};

# Represents the Queries record for the operation: restore-deployment-resource
public type RestoreDeploymentResourceQueries record {
    # Whether or not to restore a snapshot for those resources that allow it
    @http:Query {name: "restore_snapshot"}
    boolean restoreSnapshot = false;
};

# The plan for the Enterprise Search cluster
public type EnterpriseSearchPlan record {
    @jsondata:Name {value: "enterprise_search"}
    EnterpriseSearchConfiguration enterpriseSearch;
    # Defines configuration parameters that control how the plan (i.e. consisting of the cluster topology and Enterprise Search settings) is applied
    TransientEnterpriseSearchPlanConfiguration transient?;
    @jsondata:Name {value: "cluster_topology"}
    EnterpriseSearchTopologyElement[] clusterTopology?;
};

# SAML2 IdP configuration object
public type SamlIdp record {
    # Base64-encoded PEM-format X.509 certificate
    @jsondata:Name {value: "public_certificate"}
    string[] publicCertificate;
    # The IdP SAML HTTP-POST endpoint URL that will receive SAML requests during SP-initiated login
    @jsondata:Name {value: "sso_url"}
    string ssoUrl;
    # The IdP URI that identifies the issuer of a SAML2 response message assertion
    string issuer;
};

# The settings for the Integrations Server
public type IntegrationsServerSettings record {
    # The top-level configuration settings for the Elasticsearch cluster
    ClusterMetadataSettings metadata?;
};

# A query that uses simple query string syntax. Will ignore invalid syntax
public type SimpleQueryStringQuery record {
    # If `true`, the parse creates a `match_phrase` uery for each multi-position token. Defaults to `true`
    @jsondata:Name {value: "auto_generate_synonyms_phrase_query"}
    boolean autoGenerateSynonymsPhraseQuery?;
    # The query expressed in simple query string syntax
    string query;
    # If `true`, the query attempts to analyze wildcard terms. Defaults to `false`
    @jsondata:Name {value: "analyze_wildcard"}
    boolean analyzeWildcard?;
    # List of enabled operators for the simple query string syntax. Defaults to `ALL`
    string flags?;
    # Minimum number of clauses that must match for a document to be returned
    @jsondata:Name {value: "minimum_should_match"}
    string minimumShouldMatch?;
    # If `true`, edits for fuzzy matching include transpositions of two adjacent characters. Defaults to `false`
    @jsondata:Name {value: "fuzzy_transpositions"}
    boolean fuzzyTranspositions?;
    # Number of beginning characters left unchanged for fuzzy matching. Defaults to 0
    @jsondata:Name {value: "fuzzy_prefix_length"}
    int:Signed32 fuzzyPrefixLength?;
    # If `true`, format-based errors, such as providing a text value for a numeric field are ignored. Defaults to `false`
    boolean lenient?;
    # The boolean operator used to combine the terms of the query. Valid values are `OR` (default) and `AND`
    @jsondata:Name {value: "default_operator"}
    string defaultOperator?;
    # The name of the analyzer to use to convert the query text into tokens
    string analyzer?;
    # Maximum number of terms to which the query expands for fuzzy matching. Defaults to 50
    @jsondata:Name {value: "fuzzy_max_expansions"}
    int:Signed32 fuzzyMaxExpansions?;
    # Suffix appended to quoted text in the query string
    @jsondata:Name {value: "quote_field_suffix"}
    string quoteFieldSuffix?;
    # Array of fields to search
    string[] fields?;
};

# Represents the Queries record for the operation: delete-traffic-filter-ruleset
public type DeleteTrafficFilterRulesetQueries record {
    # When true, ignores the associations and deletes the ruleset. When false, recognizes the associations, which prevents the deletion of the rule set
    @http:Query {name: "ignore_associations"}
    boolean ignoreAssociations = false;
};

# AppSearch related configuration of an Elastic Stack version
public type StackVersionAppSearchConfig record {
    @jsondata:Name {value: "capacity_constraints"}
    StackVersionInstanceCapacityConstraint capacityConstraints?;
    # Settings that are applied to all nodes of this type
    record {} settings?;
    # Node types that are supported by this stack version
    @jsondata:Name {value: "node_types"}
    StackVersionNodeType[] nodeTypes?;
    # Node types that are compatible with this one
    @jsondata:Name {value: "compatible_node_types"}
    string[] compatibleNodeTypes?;
    # List of configuration options that cannot be overridden by user settings
    string[] blacklist;
    # Version of AppSearch
    string version?;
    # Docker image for the AppSearch
    @jsondata:Name {value: "docker_image"}
    string dockerImage;
};

public type ReplyWarning record {
    # A structured code representing the error type that occurred
    string code;
    # A human readable message describing the warning that occurred
    string message?;
};

# Information about the App Search Server plan
public type AppSearchPlanInfo record {
    # Either the plan ended successfully, or is not yet completed (and no errors have occurred)
    boolean healthy;
    ClusterPlanWarning[] warnings;
    # If this plan completed or failed (ie is not pending), when the attempt ended (ISO format in UTC)
    @jsondata:Name {value: "attempt_end_time"}
    string attemptEndTime?;
    # A container for information about the source of a change
    ChangeSourceInfo 'source?;
    # Information about an error during a plan attempt
    ClusterPlanAttemptError 'error?;
    # The plan for the App Search cluster
    AppSearchPlan plan?;
    @jsondata:Name {value: "plan_attempt_log"}
    ClusterPlanStepInfo[] planAttemptLog;
    # If this plan is not current or pending, when the plan was no longer active (ISO format in UTC)
    @jsondata:Name {value: "plan_end_time"}
    string planEndTime?;
    # A UUID for each plan attempt
    @jsondata:Name {value: "plan_attempt_id"}
    string planAttemptId?;
    # A human readable name for each plan attempt, only populated when retrieving plan histories
    @jsondata:Name {value: "plan_attempt_name"}
    string planAttemptName?;
    # When this plan attempt (ie to apply the plan to the App Search) started (ISO format in UTC)
    @jsondata:Name {value: "attempt_start_time"}
    string attemptStartTime?;
};

# Information about each Kibana instance and APM Server in the Elasticsearch cluster
public type ClusterInstanceInfo record {
    # The name of the instance in Elastic Cloud
    @jsondata:Name {value: "instance_name"}
    string instanceName;
    # Information about the specific instances memory capacity and its usage
    ClusterInstanceMemoryInfo memory?;
    # Whether the service is is maintenance mode (meaning that the proxy is not routing external traffic to it)
    @jsondata:Name {value: "maintenance_mode"}
    boolean maintenanceMode;
    # List of roles assigned to the service running in the instance. Currently only populated for Elasticsearch, with possible values: master,data,ingest,ml
    @jsondata:Name {value: "service_roles"}
    string[] serviceRoles?;
    # The id of the allocator on which this instance is running (if the container is started or starting)
    @jsondata:Name {value: "allocator_id"}
    string allocatorId?;
    # The version of the service that the instance is running (eg Elasticsearch or Kibana), if available
    @jsondata:Name {value: "service_version"}
    string serviceVersion?;
    # Whether the service launched inside the container -ie Elasticsearch- is actually running
    @jsondata:Name {value: "service_running"}
    boolean serviceRunning;
    @jsondata:Name {value: "instance_overrides"}
    InstanceOverrides instanceOverrides?;
    # Whether the container has started (does not tell you anything about the service -ie Elasticsearch- running inside the container)
    @jsondata:Name {value: "container_started"}
    boolean containerStarted;
    # Information about the use and storage capacity of a Kibana instance or APM Server
    ClusterInstanceDiskInfo disk?;
    @jsondata:Name {value: "instance_configuration"}
    ClusterInstanceConfigurationInfo instanceConfiguration?;
    # The zone in which this instance is being allocated
    string zone?;
    # Whether the instance is healthy (ie started and running)
    boolean healthy;
    # A list of the node roles assigned to the service running in the instance. Currently populated only for Elasticsearch
    @jsondata:Name {value: "node_roles"}
    ("master"|"ingest"|"ml"|"data_hot"|"data_content"|"data_warm"|"data_cold"|"data_frozen"|"remote_cluster_client"|"transform"|"voting_only")[] nodeRoles?;
};

# The configuration settings for the timeout and fallback parameters
public type KibanaPlanControlConfiguration record {
    # Set to 'forced' to force a reboot as part of the upgrade plan
    @jsondata:Name {value: "cluster_reboot"}
    "forced" clusterReboot?;
    # This timeout determines how long to give a cluster after it responds to API calls before performing actual operations on it. It defaults to 5s
    @jsondata:Name {value: "calm_wait_time"}
    int calmWaitTime?;
    # The total timeout in seconds after which the plan is cancelled even if it is not complete. Defaults to 4x the max memory capacity per node (in MB)
    int timeout?;
    # If true (default false), does not clear the maintenance flag (which prevents its API from being accessed except by the constructor) on new instances added until after a snapshot has been restored, otherwise, the maintenance flag is cleared once the new instances successfully join the new cluster
    @jsondata:Name {value: "extended_maintenance"}
    boolean extendedMaintenance?;
};

# An Elasticsearch search request with a subset of options
public type SearchRequest record {
    # To retrieve the next page of hits, set this to the cursor value of the previous response. When set, all other fields are ignored
    string cursor?;
    # The maximum number of search results to return
    int:Signed32 size?;
    # The container for all of the allowed Elasticsearch queries. Specify only one property each time
    QueryContainer query?;
    # Deprecated, use cursor for a more scalable approach to paging
    int:Signed32 'from?;
    # An array of fields to sort the search results by. Defaults to query rank and last modified date descending
    record {}[] sort?;
};

# A request for updating a Deployment consisting of multiple resources
public type DeploymentUpdateRequest record {
    # Additional configuration for the new deployment object
    DeploymentUpdateSettings settings?;
    # Additional information about the current deployment object
    DeploymentUpdateMetadata metadata?;
    # A new name for the deployment, otherwise stays the same
    string name?;
    # Describes the Deployment resource updates
    DeploymentUpdateResources resources?;
    # A user-defined alias to use in place of Cluster IDs for user-friendly URLs
    string alias?;
    # Whether or not to prune orphan resources that are no longer mentioned in this request. Note that resourcesare tracked by ref_id, and if a resource's ref_id is changed, any previous running resources created with that previousref_id are considered to be orphaned as well
    @jsondata:Name {value: "prune_orphans"}
    boolean pruneOrphans;
};

# Assignments for roles with project scope
public type ProjectRoleAssignments record {
    # The Security project-scoped role assignments to set
    ProjectRoleAssignment[] security?;
    # The Elasticsearch project-scoped role assignments to set
    ProjectRoleAssignment[] elasticsearch?;
    # The Observability project-scoped role assignments to set
    ProjectRoleAssignment[] observability?;
};

public type RoleMappingGroupRule record {
    # The group to match. Can have wildcards
    string group;
};

# The request payload that deletes the API keys
public type DeleteApiKeysRequest record {
    # The list of API key IDs
    string[] keys;
};

# Observability information for a deployment
public type DeploymentObservability record {
    # Whether the deployment observability is healthy or not (one or more of the subsections will have healthy: false)
    boolean healthy;
    # Logging information for a deployment
    DeploymentLogging logging?;
    # Metrics information for a deployment
    DeploymentMetrics metrics?;
    # General observability health issues for the deployment
    ObservabilityIssue[] issues?;
};

# A certificate used to sign the certificates of this deployment
public type PublicCertificate record {
    # The certificate MetaData
    CertificateMetaData metadata;
    # If true, this certificate is the one which has been used to sign the current certificates. Otherwise, it may be the one that will be used when this certificate expires
    boolean active;
    # The public certificate as string in PEM format
    string pem;
};

# Represents the Queries record for the operation: get-deployment-template-v2
public type GetDeploymentTemplateV2Queries record {
    # If true, will return details for each instance configuration referenced by the template
    @http:Query {name: "show_instance_configurations"}
    boolean showInstanceConfigurations = true;
    # If true, will populate the max_zones field in the instance configurations. Only relevant if show_instance_configurations=true
    @http:Query {name: "show_max_zones"}
    boolean showMaxZones = false;
    # If present, it will cause the returned deployment template to be adapted to return only the elements allowed in that version
    @http:Query {name: "stack_version"}
    string stackVersion?;
    # Region of the deployment template
    string region;
};

# Detailed costs for a deployment for an organization. All of the costs are expressed in Elastic Consumption Unit (ECU)
public type DeploymentCosts record {
    # Costs overview for an organization. All of the costs, credits, trials are expressed in Elastic Consumption Unit (ECU)
    Costs costs;
    # Period
    Period period?;
    # Price per hour
    @jsondata:Name {value: "hourly_rate"}
    decimal hourlyRate;
    # Elasticsearch deployment name
    @jsondata:Name {value: "deployment_name"}
    string deploymentName;
    # Elasticsearch deployment id
    @jsondata:Name {value: "deployment_id"}
    string deploymentId;
};

# Additional configuration for the new deployment object
public type DeploymentUpdateSettings record {
    @jsondata:Name {value: "auto_ops"}
    AutoOpsSettings autoOps?;
    # Enable autoscaling for this deployment
    @jsondata:Name {value: "autoscaling_enabled"}
    boolean autoscalingEnabled?;
    # The observability settings for a deployment
    DeploymentObservabilitySettings observability?;
};

# The configuration for the restore command, such as which indices you want to restore
public type RestoreSnapshotApiConfiguration record {
    # The list of indices to restore (supports +ve and -ve selection and wildcarding - see the default Elasticsearch index format documentation)
    string[] indices?;
    # This JSON object (merged with the 'indices' field (if present) is passed untouched into the restore command - see the Elasticsearch '_snapshot' documentation for more details on supported formats
    @jsondata:Name {value: "raw_settings"}
    record {} rawSettings?;
};

# A query for documents that match boolean combinations of other queries
public type BoolQuery record {
    QueryContainer[] filter?;
    QueryContainer[] should?;
    @jsondata:Name {value: "must_not"}
    QueryContainer[] mustNot?;
    # The minimum number of optional should clauses to match
    @jsondata:Name {value: "minimum_should_match"}
    int:Signed32 minimumShouldMatch?;
    QueryContainer[] must?;
};

# A collection of extensions
public type Extensions record {
    # The list of extensions
    Extension[] extensions;
};

# Represents the Queries record for the operation: enable-deployment-resource-ilm
public type EnableDeploymentResourceIlmQueries record {
    # When `true`, does not enable ILM but returns warnings if any applications may lose availability during ILM migration
    @http:Query {name: "validate_only"}
    boolean validateOnly = false;
};

# Logging information for a deployment
public type DeploymentLogging record {
    # The URLs to view this deployment's logs in Kibana
    record {|string...;|} urls?;
    # Whether the deployment logging is healthy or not
    boolean healthy;
    # Logging health issues for the deployment
    ObservabilityIssue[] issues?;
};

# Describes an App Search resource belonging to a Deployment
public type AppSearchResourceInfo record {
    # The locally-unique user-specified id of a Resource
    @jsondata:Name {value: "ref_id"}
    string refId;
    # The Elasticsearch cluster that this resource depends on
    @jsondata:Name {value: "elasticsearch_cluster_ref_id"}
    string elasticsearchClusterRefId;
    # The randomly-generated id of a Resource
    string id;
    # The region where this resource exists
    string region;
    # The overview information for the App Search Server
    AppSearchInfo info;
};

# DTS Rate
public type DtsRate record {
    # Raw rate
    decimal value;
    # Rate in human readable format
    @jsondata:Name {value: "formatted_value"}
    string formattedValue;
};

# Issues that prevent the Elasticsearch cluster or index from correctly operating
public type ElasticsearchBlockingIssues record {
    # Whether the cluster has issues (false) or not (true)
    boolean healthy;
    # A list of blocks that affect the availability of the cluster
    ElasticsearchBlockingIssueElement[] blocks;
};

# The index curation settings for an Elasticsearch cluster
public type ClusterCurationSettings record {
    # Specifications for curation
    ClusterCurationSpec[] specs;
};

# Information about a configuration that creates a Kibana instance or APM Server
public type ClusterInstanceConfigurationInfo record {
    # The resource type of the instance configuration
    "memory"|"storage" 'resource;
    # The name of the configuration used to create the instance
    string name;
    # The id of the configuration used to create the instance
    string id;
    # If the IC is configuration controlled, this field is the version either being read back (reads return the latest IC unless specified by the 'config_version' URL param), or the version to update. Cannot be used in creates. For unversioned IC reads it is left empty
    @jsondata:Name {value: "config_version"}
    int:Signed32 configVersion?;
};

# The body of a request to update an extension
public type UpdateExtensionRequest record {
    # The extension name
    string name;
    # The URL to download the extension archive
    @jsondata:Name {value: "download_url"}
    string downloadUrl?;
    # The extension description
    string description?;
    # The extension type
    @jsondata:Name {value: "extension_type"}
    "plugin"|"bundle" extensionType;
    # The Elasticsearch version
    string version;
};

# Represents the Queries record for the operation: get-traffic-filter-claimed-link-ids
public type GetTrafficFilterClaimedLinkIdsQueries record {
    # Retrieves a list of resources that are associated to the specified organization ID. It only takes effect if the user is an admin
    @http:Query {name: "organization_id"}
    string organizationId?;
    # If provided limits the claimed id to that region only
    string region?;
};

# A query for documents that contain the specified term in the inverted index
public type TermQuery record {
    # The exact value to query for
    string value;
};

# A strategy that creates new Elasticsearch instances, Kibana instances, and APM Servers with the new plan, then migrates the node data to minimize the amount of spare capacity
public type RollingGrowShrinkStrategyConfig record {
};

# Information about current, pending, and past APM Server plans
public type ApmPlansInfo record {
    # Information about the APM Server plan
    ApmPlanInfo current?;
    # Whether the plan situation is healthy (if unhealthy, means the last plan attempt failed)
    boolean healthy;
    # Information about the APM Server plan
    ApmPlanInfo pending?;
    ApmPlanInfo[] history;
};

# Metrics information for a deployment
public type DeploymentMetrics record {
    # The URLs to view this deployment's metrics in Kibana
    record {|string...;|} urls?;
    # Whether the deployment metrics are healthy or not
    boolean healthy;
    # Metrics health issues for the deployment
    ObservabilityIssue[] issues?;
};

# Line Item
public type SimplifiedLineItem record {
    # Elastic Consumption Unit (ECU) Balance
    @jsondata:Name {value: "ecu_balance"}
    decimal ecuBalance;
    # Original Elastic Consumption Unit (ECU) quantity
    @jsondata:Name {value: "ecu_quantity"}
    decimal ecuQuantity;
    # Start of the line item's validity
    string 'start;
    # Expiration of the line item
    string end;
    # Line Item ID
    string id;
};

# Information about the current, pending, and past Elasticsearch cluster plans
public type ElasticsearchClusterPlansInfo record {
    # Information about the Elasticsearch cluster plan
    ElasticsearchClusterPlanInfo current?;
    # Whether the plan situation is healthy (if unhealthy, means the last plan attempt failed)
    boolean healthy;
    # Information about the Elasticsearch cluster plan
    ElasticsearchClusterPlanInfo pending?;
    ElasticsearchClusterPlanInfo[] history;
};

# An invitation to an organization
public type OrganizationInvitation record {
    @jsondata:Name {value: "role_assignments"}
    RoleAssignments roleAssignments?;
    # The date and time when the invitation expires
    @jsondata:Name {value: "expires_at"}
    string expiresAt;
    # True if the invitation is expired
    boolean expired;
    # An organization
    Organization organization;
    # The date and time when the invitation was created
    @jsondata:Name {value: "created_at"}
    string createdAt;
    # The date and time when the invitation was accepted
    @jsondata:Name {value: "accepted_at"}
    string acceptedAt?;
    # The email address to invite to the organization
    string email;
    # The token used to accept the invitation
    string token;
};

# The plan for the Kibana instance
public type KibanaClusterPlan record {
    # Defines the configuration parameters that control how the plan is applied. For example, the Elasticsearch cluster topology and Kibana instance settings
    TransientKibanaPlanConfiguration transient?;
    @jsondata:Name {value: "cluster_topology"}
    KibanaClusterTopologyElement[] clusterTopology?;
    # The Kibana instance settings. When specified at the top level, provides a field-by-field default. When specified at the topology level, provides the override settings
    KibanaConfiguration kibana;
};

# The configuration settings for the traffic filter
public type TrafficFilterSettings record {
    # IDs of the traffic filter rulesets
    string[] rulesets;
};

# Defines the configuration parameters that control how the plan is applied. For example, the Elasticsearch cluster topology and Kibana instance settings
public type TransientKibanaPlanConfiguration record {
    @jsondata:Name {value: "plan_configuration"}
    KibanaPlanControlConfiguration planConfiguration?;
    # The options for performing a plan change. Specify only one property each time. The default is `grow_and_shrink`
    PlanStrategy strategy?;
};

public type ExtensionsextensionIdBody record {
    # Zip file that contains the extension
    record {byte[] fileContent; string fileName;} file;
};

public type EnterpriseSearchPlanControlConfiguration record {
    # List of allocators on which instances are placed if possible (if not possible/not specified then any available allocator with space is used)
    @jsondata:Name {value: "preferred_allocators"}
    string[] preferredAllocators?;
    # Set to 'forced' to force a reboot as part of the upgrade plan
    @jsondata:Name {value: "cluster_reboot"}
    "forced" clusterReboot?;
    @jsondata:Name {value: "move_allocators"}
    AllocatorMoveRequest[] moveAllocators?;
    # This timeout determines how long to give a cluster after it responds to API calls before performing actual operations on it. It defaults to 5s
    @jsondata:Name {value: "calm_wait_time"}
    int calmWaitTime?;
    @jsondata:Name {value: "move_instances"}
    InstanceMoveRequest[] moveInstances?;
    # If true (default: false) does not allow re-using any existing instances currently in the cluster, i.e. even unchanged instances will be re-created
    @jsondata:Name {value: "reallocate_instances"}
    boolean reallocateInstances?;
    # The total timeout in seconds after which the plan is cancelled even if it is not complete. Defaults to 4x the max memory capacity per node (in MB)
    int timeout?;
    # If true (default false), does not clear the maintenance flag (which prevents its API from being accessed except by the constructor) on new instances added until after a snapshot has been restored, otherwise, the maintenance flag is cleared once the new instances successfully join the new cluster
    @jsondata:Name {value: "extended_maintenance"}
    boolean extendedMaintenance?;
};

# Represents the Queries record for the operation: enable-deployment-resource-ccr
public type EnableDeploymentResourceCcrQueries record {
    # When `true`, will not enable CCR but returns warnings if any elements may lose availability during CCR enablement
    @http:Query {name: "validate_only"}
    boolean validateOnly = false;
};

# The plan for the Integrations Server
public type IntegrationsServerPlan record {
    # Defines the configuration parameters that control how the plan is applied. For example, the Elasticsearch cluster topology and Integrations Server settings
    TransientIntegrationsServerPlanConfiguration transient?;
    @jsondata:Name {value: "cluster_topology"}
    IntegrationsServerTopologyElement[] clusterTopology?;
    @jsondata:Name {value: "integrations_server"}
    IntegrationsServerConfiguration integrationsServer;
};

# AutoOps settings for this deployment
public type AutoOpsSettings record {
    # See AutoOps integration status for this deployment
    "connected"|"not_connected"|"excluded" status;
};

# The top-level configuration settings for the Elasticsearch cluster
public type ClusterMetadataSettings record {
    # The display name of the cluster
    string name?;
};

# An API extension. It represents clusters' plugins and bundles
public type Extension record {
    # List of deployments using this extension. Up to only 10000 deployments will be included in the list
    string[] deployments?;
    # The extension name
    string name;
    # The download URL specified during extension creation
    @jsondata:Name {value: "download_url"}
    string downloadUrl?;
    # The extension description
    string description?;
    # The extension ID
    string id;
    @jsondata:Name {value: "file_metadata"}
    ExtensionFileMetadata fileMetadata?;
    # The extension type
    @jsondata:Name {value: "extension_type"}
    "plugin"|"bundle" extensionType;
    # The Elasticsearch version
    string version;
    # The extension URL to be used in the plan
    string url;
};

# Envelope holding the newly-reset password for a cluster's user
public type ElasticsearchElasticUserPasswordResetResponse record {
    # The newly-reset password for the given Elasticsearch cluster
    string password;
    # The username for the newly-reset password for the given Elasticsearch cluster
    string username;
};

# > WARNING
# > This endpoint is deprecated and scheduled to be removed in the next major version. Use `blocks` in `cluster_blocking_issues` instead
# 
# Information about an issue and the Elasticsearch instance it affects
public type ElasticsearchClusterBlockingIssueElement record {
    # A list of instances that are affected by the issue
    string[] instances;
    # Description of the issue
    string description;
};

# The settings for the APM Server
public type ApmSettings record {
    # The top-level configuration settings for the Elasticsearch cluster
    ClusterMetadataSettings metadata?;
};

# > WARNING
# > This endpoint is deprecated and scheduled to be removed in the next major version. Use `shards_status` instead.
# 
# Information about the shards and replicas that comprise the Elasticsearch indices
public type ElasticsearchShardsInfo record {
    # Whether the shard situation is healthy (any unavailable shards is unhealthy)
    boolean healthy;
    @jsondata:Name {value: "unavailable_replicas"}
    ElasticsearchReplicaElement[] unavailableReplicas;
    @jsondata:Name {value: "available_shards"}
    ElasticsearchShardElement[] availableShards;
    @jsondata:Name {value: "unavailable_shards"}
    ElasticsearchShardElement[] unavailableShards;
};

# The specification for traffic filter claimed link id
public type TrafficFilterClaimedLinkIdRequest record {
    # Resource GUID of the Azure Private Endpoint to allow connections from
    @jsondata:Name {value: "azure_endpoint_guid"}
    string azureEndpointGuid?;
    # Name of the Azure Private Endpoint to allow connections from
    @jsondata:Name {value: "azure_endpoint_name"}
    string azureEndpointName?;
    # The claimed link id can be used only for traffic filter in the specific region
    string region;
    # Link id. A GCP private service connect ID or AWS VPC endpoint ID
    @jsondata:Name {value: "link_id"}
    string linkId?;
};

# Holds diagnostics for an AppSearch resource
public type AppSearch record {
    # A locally-unique user-specified id
    @jsondata:Name {value: "ref_id"}
    string refId;
    # The user-specified id of the Elasticsearch Cluster that this will link to
    @jsondata:Name {value: "elasticsearch_cluster_ref_id"}
    string elasticsearchClusterRefId;
    # The backend plan as JSON
    @jsondata:Name {value: "backend_plan"}
    record {} backendPlan;
    # The human readable name (defaults to the generated cluster id if not specified)
    @jsondata:Name {value: "display_name"}
    string displayName;
};

# Settings related to the level of trust of the clusters in this account
public type AccountTrustSettings record {
    # If true, all clusters in this account will by default trust all other clusters in the same account
    @jsondata:Name {value: "trust_all"}
    boolean trustAll;
};

# A response returned from the Deployment shutdown endpoint
public type DeploymentShutdownResponse record {
    # The name of the deployment
    string name;
    # Details about orphaned resources
    Orphaned orphaned?;
    # The id of the deployment
    string id;
};

# Describes an Integrations Server resource belonging to a Deployment
public type IntegrationsServerResourceInfo record {
    # The locally-unique user-specified id of a Resource
    @jsondata:Name {value: "ref_id"}
    string refId;
    # The Elasticsearch cluster that this resource depends on
    @jsondata:Name {value: "elasticsearch_cluster_ref_id"}
    string elasticsearchClusterRefId;
    # The randomly-generated id of a Resource
    string id;
    # The region where this resource exists
    string region;
    # The overview information for the Integrations Server
    IntegrationsServerInfo info;
};

# Information about current, pending, and past Integrations Server plans
public type IntegrationsServerPlansInfo record {
    # Information about the Integrations Server plan
    IntegrationsServerPlanInfo current?;
    # Whether the plan situation is healthy (if unhealthy, means the last plan attempt failed)
    boolean healthy;
    # Information about the Integrations Server plan
    IntegrationsServerPlanInfo pending?;
    IntegrationsServerPlanInfo[] history;
};

# Configures the location of a remote repository. The default is the system repository
public type RestoreSnapshotRepoConfiguration record {
    # The remote snapshot settings raw JSON - see the Elasticsearch '_snapshot' documentation for more details on supported formats
    @jsondata:Name {value: "raw_settings"}
    record {} rawSettings?;
};

# Information about the shards for each Elasticsearch instance container that hosts an Elasticsearch node. TIP: When the shard is unavailable, the cluster is unable to serve all of the data
public type ElasticsearchShardElement record {
    # The Elastic Cloud name/id of the instance (container)
    @jsondata:Name {value: "instance_name"}
    string instanceName;
    # The number of shards of the given type (available/unavailable) on this instance
    @jsondata:Name {value: "shard_count"}
    int:Signed32 shardCount;
};

# The details for an Elastic Stack configuration
public type StackVersionConfig record {
    # The template information for an Elastic Stack version
    StackVersionTemplateInfo template;
    # Whether or not this version is accessible by the calling user. This is only relevant in EC (SaaS) and is not sent in ECE
    boolean accessible?;
    # The metadata for the Elastic Stack
    StackVersionMetadata metadata?;
    # Stack version
    string version?;
    # AppSearch related configuration of an Elastic Stack version
    StackVersionAppSearchConfig appsearch?;
    # Identifies that the Elastic Stack version is marked for deletion
    boolean deleted?;
    # The Elasticsearch configuration for an Elastic Stack version. 
    StackVersionElasticsearchConfig elasticsearch;
    # The minimum version recommended to upgrade this version
    @jsondata:Name {value: "min_upgradable_from"}
    string minUpgradableFrom?;
    # List of versions that can be upgraded to the current version of the stackpack
    @jsondata:Name {value: "rolling_upgrade_compatible_versions"}
    string[] rollingUpgradeCompatibleVersions?;
    # Stack Versions that this version can upgrade to
    @jsondata:Name {value: "upgradable_to"}
    string[] upgradableTo;
    # Whether or not this version is whitelisted. This is only relevant in EC (SaaS) and is not sent in ECE
    boolean whitelisted?;
    # The Kibana configuration for an Elastic Stack version
    StackVersionKibanaConfig kibana;
    # The APM Server configuration for an Elastic Stack version
    StackVersionApmConfig apm?;
};

# A ChartItem value
public type ChartItemValue record {
    # The name of the chart item value
    string name;
    # The id of chart item value
    string id;
    # The actual value of the chart item value
    decimal value;
};

# A user's membership to an organization
public type OrganizationMembership record {
    # The date and time the user was added to the organization
    @jsondata:Name {value: "member_since"}
    string memberSince;
    @jsondata:Name {value: "role_assignments"}
    RoleAssignments roleAssignments?;
    # The users's identifier
    @jsondata:Name {value: "user_id"}
    string userId;
    # The organization's identifier
    @jsondata:Name {value: "organization_id"}
    string organizationId;
    # The user's full name
    string name?;
    # The user's email address
    string email?;
};

# The response model for an API key
public type ApiKeyResponse record {
    @jsondata:Name {value: "role_assignments"}
    RoleAssignments roleAssignments?;
    # The user ID
    @jsondata:Name {value: "user_id"}
    string userId?;
    # The organization ID linked to the API key
    @jsondata:Name {value: "organization_id"}
    string organizationId?;
    # The API key description. TIP: Useful when you have multiple API keys
    string description;
    # The API key ID
    string id;
    # The date/time for when the API key is created
    @jsondata:Name {value: "creation_date"}
    string creationDate;
    # The date/time when the API key expires
    @jsondata:Name {value: "expiration_date"}
    string expirationDate?;
    # The API key. TIP: Since the API key is returned only once, save it in a safe place
    string 'key?;
};

# The Kibana configuration for an Elastic Stack version
public type StackVersionKibanaConfig record {
    @jsondata:Name {value: "capacity_constraints"}
    StackVersionInstanceCapacityConstraint capacityConstraints?;
    # Settings that are applied to all nodes of this type
    record {} settings?;
    # Node types that are compatible with this one
    @jsondata:Name {value: "compatible_node_types"}
    string[] compatibleNodeTypes?;
    # List of configuration options that cannot be overridden by user settings
    string[] blacklist;
    # Version of Kibana
    string version?;
    # Docker image for the kibana
    @jsondata:Name {value: "docker_image"}
    string dockerImage;
};

# Enables scripting for the specified type and controls other parameters. Store scripts in indexes (`stored`), upload in file bundles (`file`), or use in API requests (`inline`)
public type ElasticsearchScriptTypeSettings record {
    # If enabled (default: true) and this script type is enabled, then only the sandbox languages are allowed. By default the sandbox languages are painless, expressions and mustache, but this can be restricted via the 'painless_enabled', 'mustache_enabled' 'expression_enabled' settings.NOTES: Not supported in 6.x. (Corresponds to the parameters 'script.engine.[painless|mustache|expressions].[file|stored|inline]')
    @jsondata:Name {value: "sandbox_mode"}
    boolean sandboxMode?;
    # If enabled (default: true) then scripts are enabled, either for sandboxing languages (by default), or for all installed languages if 'sandbox_mode' is disabled (or for 6.x). NOTES: (Corresponds to the parameter 'script.file|stored/indexed|inline')
    boolean enabled?;
};

# A structure that defines a curated subset of the APM Server settings. 
# TIP: To define the complete set of APM Server setting, use `ApmSystemSettings` with `user_settings_override_` and `user_settings_`
public type ApmSystemSettings record {
    # Optionally override the account within APM - defaults to a system account that always exists (if specified, the username must also be specified). Note that this field is never returned from the API, it is write only
    @jsondata:Name {value: "elasticsearch_password"}
    string elasticsearchPassword?;
    # Optionally override the account within APM - defaults to a system account that always exists (if specified, the password must also be specified). Note that this field is never returned from the API, it is write only
    @jsondata:Name {value: "elasticsearch_username"}
    string elasticsearchUsername?;
    # Optionally enable debug mode for APM servers - defaults false
    @jsondata:Name {value: "debug_enabled"}
    boolean debugEnabled?;
    # Optionally override the secret token within APM - defaults to the previously existing secretToken
    @jsondata:Name {value: "secret_token"}
    string secretToken?;
};

# Information about the Enterprise Search Server plan
public type EnterpriseSearchPlanInfo record {
    # Either the plan ended successfully, or is not yet completed (and no errors have occurred)
    boolean healthy;
    ClusterPlanWarning[] warnings;
    # If this plan completed or failed (ie is not pending), when the attempt ended (ISO format in UTC)
    @jsondata:Name {value: "attempt_end_time"}
    string attemptEndTime?;
    # A container for information about the source of a change
    ChangeSourceInfo 'source?;
    # Information about an error during a plan attempt
    ClusterPlanAttemptError 'error?;
    # The plan for the Enterprise Search cluster
    EnterpriseSearchPlan plan?;
    @jsondata:Name {value: "plan_attempt_log"}
    ClusterPlanStepInfo[] planAttemptLog;
    # If this plan is not current or pending, when the plan was no longer active (ISO format in UTC)
    @jsondata:Name {value: "plan_end_time"}
    string planEndTime?;
    # A UUID for each plan attempt
    @jsondata:Name {value: "plan_attempt_id"}
    string planAttemptId?;
    # A human readable name for each plan attempt, only populated when retrieving plan histories
    @jsondata:Name {value: "plan_attempt_name"}
    string planAttemptName?;
    # When this plan attempt (ie to apply the plan to the Enterprise Search) started (ISO format in UTC)
    @jsondata:Name {value: "attempt_start_time"}
    string attemptStartTime?;
};

# Represents the Queries record for the operation: get-deployment
public type GetDeploymentQueries record {
    # Number of system alerts (such as forced restarts due to memory limits) to be included in the response - can be large per cluster. Negative numbers or 0 will not return field
    @http:Query {name: "show_system_alerts"}
    int showSystemAlerts = 0;
    # Whether to include with the current and pending plan information the attempt log - can be very large per cluster
    @http:Query {name: "show_plan_logs"}
    boolean showPlanLogs = false;
    # Whether to include the full current and pending plan information in the response - can be large per cluster
    @http:Query {name: "show_plans"}
    boolean showPlans = true;
    # Whether to include the Elasticsearch 2.x security information in the response - can be large per cluster and also include credentials
    @http:Query {name: "show_security"}
    boolean showSecurity = false;
    # Whether to include the plan history with the current and pending plan information. The results can be very large per cluster.
    #  By default, if a given resource kind (e.g. Elasticsearch, Kibana, etc.) has more than 100 plans
    #  (which should be very rare, most likely caused by a bug) only 100 plans are returned for the given resource type:
    #  The first 10 plans, and the last 90 plans for that resource type.
    #  If ALL of the plans are desired, pass the `force_all_plan_history` parameter with a value of `true`
    @http:Query {name: "show_plan_history"}
    boolean showPlanHistory = false;
    # If true, will return details for each instance configuration referenced by the deployment
    @http:Query {name: "show_instance_configurations"}
    boolean showInstanceConfigurations = true;
    # Whether to show resources instance metrics in the response
    @http:Query {name: "show_instance_metrics"}
    boolean showInstanceMetrics = true;
    # Whether to include the full cluster metadata in the response - can be large per cluster and also include credentials
    @http:Query {name: "show_metadata"}
    boolean showMetadata = false;
    # If showing plans, whether to leave pre-2.0.0 plans in their legacy format (the default), or whether to update them to 2.0.x+ format (if 'true')
    @http:Query {name: "convert_legacy_plans"}
    boolean convertLegacyPlans = false;
    # Whether to show cluster settings in the response
    @http:Query {name: "show_settings"}
    boolean showSettings = false;
    # If showing plans, whether to show values that are left at their default value (less readable but more informative)
    @http:Query {name: "show_plan_defaults"}
    boolean showPlanDefaults = false;
    # Force show the entire plan history no matter how long.
    #  As noted in the `show_plan_history` parameter description, by default, a maximum of 100 plans are shown per resource. 
    #  If `true`, this parameter overrides the default, and ALL plans are returned.
    #  Use with care as the plan history can be VERY large. Consider pairing with `show_plan_logs=false`.
    #  
    @http:Query {name: "force_all_plan_history"}
    boolean forceAllPlanHistory = false;
    # If set (defaults to false) then removes the transient section from all child resources, making it safe to reapply via an update
    @http:Query {name: "clear_transient"}
    boolean clearTransient = false;
    # If showing plans, whether to enrich the plan by including the missing elements from the deployment template it is based on
    @http:Query {name: "enrich_with_template"}
    boolean enrichWithTemplate = true;
};

# Represents the Queries record for the operation: restore-deployment
public type RestoreDeploymentQueries record {
    # Whether or not to restore a snapshot for those resources that allow it
    @http:Query {name: "restore_snapshot"}
    boolean restoreSnapshot = false;
};

# The settings for the App Search
public type AppSearchSettings record {
    # The top-level configuration settings for the Elasticsearch cluster
    ClusterMetadataSettings metadata?;
};

# A Kibana creation request paired with the alias of the Elasticsearch cluster it should be paired with
public type KibanaPayload record {
    # A locally-unique user-specified id for Kibana
    @jsondata:Name {value: "ref_id"}
    string refId;
    # The settings for multiple Kibana instances
    KibanaClusterSettings settings?;
    # Alias to the Elasticsearch Cluster to attach Kibana to
    @jsondata:Name {value: "elasticsearch_cluster_ref_id"}
    string elasticsearchClusterRefId;
    # The human readable name for the Kibana cluster (default: takes the name of its Elasticsearch cluster)
    @jsondata:Name {value: "display_name"}
    string displayName?;
    # The region where this resource exists
    string region;
    # The plan for the Kibana instance
    KibanaClusterPlan plan;
};

# Consumes and analyzes text, numbers, and dates, then constructs a query
public type MatchQuery record {
    # The analyzer that will be used to perform the analysis process on the text. Defaults to the analyzer that was used to index the field
    string analyzer?;
    # The text/numeric/date to query for
    string query;
    # The minimum number of optional should clauses to match
    @jsondata:Name {value: "minimum_should_match"}
    int:Signed32 minimumShouldMatch?;
    # The operator flag can be set to or or and to control the boolean clauses (defaults to or)
    string operator?;
};

# Information about the APM Server plan
public type ApmPlanInfo record {
    # Either the plan ended successfully, or is not yet completed (and no errors have occurred)
    boolean healthy;
    ClusterPlanWarning[] warnings;
    # If this plan completed or failed (ie is not pending), when the attempt ended (ISO format in UTC)
    @jsondata:Name {value: "attempt_end_time"}
    string attemptEndTime?;
    # A container for information about the source of a change
    ChangeSourceInfo 'source?;
    # Information about an error during a plan attempt
    ClusterPlanAttemptError 'error?;
    # The plan for the APM Server
    ApmPlan plan?;
    @jsondata:Name {value: "plan_attempt_log"}
    ClusterPlanStepInfo[] planAttemptLog;
    # If this plan is not current or pending, when the plan was no longer active (ISO format in UTC)
    @jsondata:Name {value: "plan_end_time"}
    string planEndTime?;
    # A UUID for each plan attempt
    @jsondata:Name {value: "plan_attempt_id"}
    string planAttemptId?;
    # A human readable name for each plan attempt, only populated when retrieving plan histories
    @jsondata:Name {value: "plan_attempt_name"}
    string planAttemptName?;
    # When this plan attempt (ie to apply the plan to the APM) started (ISO format in UTC)
    @jsondata:Name {value: "attempt_start_time"}
    string attemptStartTime?;
};

# Information about a step in a plan
public type ClusterPlanStepInfo record {
    # Human readable summaries of the step, including messages for each stage of the step
    @jsondata:Name {value: "info_log"}
    ClusterPlanStepLogMessageInfo[] infoLog;
    # Current stage that the step is in
    "starting"|"completed"|"in_progress" stage;
    # The duration of the step in MS
    @jsondata:Name {value: "duration_in_millis"}
    int durationInMillis?;
    # When the step started (ISO format in UTC)
    string started;
    # When the step completed (ISO format in UTC)
    string completed?;
    # ID of current step
    @jsondata:Name {value: "step_id"}
    string stepId;
    # The status of the step (success, warning, error - warning means something didn't go as expected but it was not serious enough to abort the plan)
    "success"|"warning"|"error"|"pending" status;
};

# Additional information about the current deployment object
public type DeploymentUpdateMetadata record {
    # Arbitrary user-defined metadata associated with this deployment
    MetadataItem[] tags?;
};

# The Elasticsearch instance, Kibana instance, APM Server capacity constraints for an Elastic Stack node type
public type StackVersionInstanceCapacityConstraint record {
    # Min capacity of the instances
    int:Signed32 min;
    # Max capacity of the instances
    int:Signed32 max;
};

# The configuration for an Elastic Stack node type
public type StackVersionNodeType record {
    @jsondata:Name {value: "capacity_constraints"}
    StackVersionInstanceCapacityConstraint capacityConstraints?;
    # Settings that are applied to all nodes of this type
    record {} settings?;
    # Node types that are compatible with this one
    @jsondata:Name {value: "compatible_node_types"}
    string[] compatibleNodeTypes?;
    # Type of the node (master, data, ...)
    @jsondata:Name {value: "node_type"}
    string nodeType;
    # Name of the node type
    string name;
    # Description of the node type
    string description;
    # Flag to specify a node type is mandatory in a cluster's plan
    boolean mandatory?;
};

# Information about index or cluster blocks
public type ElasticsearchBlockingIssueElement record {
    # Applicable level for the block. Either global ie. cluster-wide or index level
    "index"|"global" level;
    # Description of the block
    string description;
};

# The organization's IdP configuration
public type OrganizationIdpConfiguration record {
    @jsondata:Name {value: "saml_idp"}
    SamlIdp samlIdp;
    # The prefix of the login identifier that will be generated
    @jsondata:Name {value: "login_identifier_prefix"}
    string loginIdentifierPrefix;
    # Whether or not the IdP is enabled
    boolean enabled;
};

# The container for all of the allowed Elasticsearch queries. Specify only one property each time
public type QueryContainer record {
    # A query for documents that match boolean combinations of other queries
    BoolQuery bool?;
    record {|PrefixQuery...;|} prefix?;
    record {|MatchQuery...;|} 'match?;
    @jsondata:Name {value: "match_none"}
    MatchNoneQuery matchNone?;
    @jsondata:Name {value: "match_all"}
    MatchAllQuery matchAll?;
    # Matches documents that have at least one non-`null` value in the original field
    ExistsQuery exists?;
    record {|RangeQuery...;|} range?;
    record {|TermQuery...;|} term?;
    # A query that matches nested objects
    NestedQuery nested?;
    @jsondata:Name {value: "query_string"}
    QueryStringQuery queryString?;
    @jsondata:Name {value: "simple_query_string"}
    SimpleQueryStringQuery simpleQueryString?;
};

# Represents the Headers record for the operation: get-costs-deployments
public type GetCostsDeploymentsHeaders record {
    # Accept header containing the content preference
    @http:Header {name: "Accept"}
    string accept?;
};

# Assignment for a role with organization scope
public type OrganizationRoleAssignment record {
    # The ID of the role that is assigned
    @jsondata:Name {value: "role_id"}
    string roleId;
    # The ID of the organization the role is scoped to
    @jsondata:Name {value: "organization_id"}
    string organizationId;
};

# Defines the topology of the AppSearch nodes (eg number/capacity of nodes, and where they can be allocated)
public type AppSearchTopologyElement record {
    # Controls the allocation of this topology element as well as allowed sizes and node_types. It needs to match the id of an existing instance configuration
    @jsondata:Name {value: "instance_configuration_id"}
    string instanceConfigurationId?;
    # The version of the Instance Configuration Id. If it is unset, the meaning depends on read vs writes. For deployment reads, it is equivalent to version 0 (or the IC is unversioned); for deployment creates and deployment template use, it is equivalent to 'the latest version'; and for deployment updates, it is equivalent to 'retain the current version'
    @jsondata:Name {value: "instance_configuration_version"}
    int:Signed32 instanceConfigurationVersion?;
    @jsondata:Name {value: "node_type"}
    AppSearchNodeTypes nodeType?;
    # Measured by the amount of a resource. The final cluster size is calculated using multipliers from the topology instance configuration
    TopologySize size?;
    # number of zones in which nodes will be placed
    @jsondata:Name {value: "zone_count"}
    int:Signed32 zoneCount?;
    AppSearchConfiguration appsearch?;
};

# Represents the Queries record for the operation: enable-deployment-resource-slm
public type EnableDeploymentResourceSlmQueries record {
    # When `true`, does not enable SLM but returns warnings if any applications may lose availability during SLM migration
    @http:Query {name: "validate_only"}
    boolean validateOnly = false;
};

# Represents the Queries record for the operation: get-deployment-templates-v2
public type GetDeploymentTemplatesV2Queries record {
    # If true, will return details for each instance configuration referenced by the template
    @http:Query {name: "show_instance_configurations"}
    boolean showInstanceConfigurations = true;
    # If true, will populate the max_zones field in the instance configurations. Only relevant if show_instance_configurations=true
    @http:Query {name: "show_max_zones"}
    boolean showMaxZones = false;
    # An optional key/value pair in the form of (key:value) that will act as a filter and exclude any templates that do not have a matching metadata item associated
    string metadata?;
    # If true, templates flagged as deprecated will NOT be returned
    @http:Query {name: "hide_deprecated"}
    boolean hideDeprecated = false;
    # If present, it will cause the returned deployment templates to be adapted to return only the elements allowed in that version
    @http:Query {name: "stack_version"}
    string stackVersion?;
    # Region of the deployment templates
    string region;
};

# The template file hash for an Elastic Stack version
public type StackVersionTemplateFileHash record {
    # File path relative to template's root
    string path;
    # SHA-256 hash of a file
    string hash;
};

# Details about an orphaned Elasticsearch resources
public type OrphanedElasticsearch record {
    # List of orphaned dependent resources
    ElasticsearchDependant[] dependents;
    # The id of the orphaned resource
    string id;
};

# Information about the master nodes in the Elasticsearch cluster
public type ElasticsearchMasterInfo record {
    # Whether the master situation in the cluster is healthy (ie is the number of masters != 1), or do any instances have no master
    boolean healthy;
    ElasticsearchMasterElement[] masters;
    # A list of any instances with no master
    @jsondata:Name {value: "instances_with_no_master"}
    string[] instancesWithNoMaster;
};

# A list of admin-uploaded plugin objects
public type ElasticsearchUserPlugin record {
    # The supported Elasticsearch version (must match the version in the plan)
    @jsondata:Name {value: "elasticsearch_version"}
    string elasticsearchVersion;
    # The name of the plugin
    string name;
    # The URL of the plugin (must be accessible from the ECE infrastructure)
    string url;
};

# Defines configuration parameters that control how the plan (i.e. consisting of the cluster topology and Enterprise Search settings) is applied
public type TransientEnterpriseSearchPlanConfiguration record {
    @jsondata:Name {value: "plan_configuration"}
    EnterpriseSearchPlanControlConfiguration planConfiguration?;
    # The options for performing a plan change. Specify only one property each time. The default is `grow_and_shrink`
    PlanStrategy strategy?;
};

# The overview information for the Enterprise Search Server
public type EnterpriseSearchInfo record {
    # The settings for the Enterprise Search
    EnterpriseSearchSettings settings?;
    # Information about the public and internal state, and the configuration settings of an Elasticsearch cluster
    ClusterMetadataInfo metadata?;
    # The topology for Elasticsearch clusters, multiple Kibana instances, or multiple APM Servers. The `ClusterTopologyInfo` also includes the instances and containers, and where they are located
    ClusterTopologyInfo topology;
    @jsondata:Name {value: "plan_info"}
    EnterpriseSearchPlansInfo planInfo;
    @jsondata:Name {value: "elasticsearch_cluster"}
    TargetElasticsearchCluster elasticsearchCluster;
    # Whether the Enterprise Search is healthy or not (one or more of the info subsections will have healthy: false)
    boolean healthy;
    # External resources related to the Enterprise Search
    @jsondata:Name {value: "external_links"}
    ExternalHyperlink[] externalLinks;
    # The name of the Enterprise Search
    string name;
    # A map of application-specific operations (which map to 'operationId's in the Swagger API) to metadata about that operation
    record {|Hyperlink...;|} links?;
    # The id of the Enterprise Search
    string id;
    # The id of the deployment that this Enterprise Search belongs to
    @jsondata:Name {value: "deployment_id"}
    string deploymentId?;
    # The region that this Enterprise Search belongs to. Only populated in SaaS or federated ECE
    string region?;
    # Enterprise Search status
    "initializing"|"stopping"|"stopped"|"rebooting"|"restarting"|"reconfiguring"|"started" status;
};

# A structure that defines a curated subset of the Integrations Server settings. 
# TIP: To define the complete set of Integrations Server setting, use `IntegrationsSystemSettings` with `user_settings_override_` and `user_settings_`
public type IntegrationsServerSystemSettings record {
    # Optionally override the account within Integrations Server - defaults to a system account that always exists (if specified, the username must also be specified). Note that this field is never returned from the API, it is write only
    @jsondata:Name {value: "elasticsearch_password"}
    string elasticsearchPassword?;
    # Optionally override the account within Integrations Server - defaults to a system account that always exists (if specified, the password must also be specified). Note that this field is never returned from the API, it is write only
    @jsondata:Name {value: "elasticsearch_username"}
    string elasticsearchUsername?;
    # Optionally enable debug mode for Integrations Server - defaults false
    @jsondata:Name {value: "debug_enabled"}
    boolean debugEnabled?;
    # Optionally override the secret token within Integrations Server - defaults to the previously existing secretToken
    @jsondata:Name {value: "secret_token"}
    string secretToken?;
};

# Describes a searched Deployment
public type DeploymentSearchResponse record {
    # Additional configuration about the current deployment object
    DeploymentSettings settings?;
    # Additional information about the current deployment object
    DeploymentMetadata metadata?;
    # Whether the deployment is overall healthy or not (one or more of the resource info subsections will have healthy: false)
    boolean healthy;
    # The name of this deployment
    string name;
    # A user-defined deployment alias for user-friendly resource URLs
    string alias?;
    # Describes a resource belonging to a Deployment
    DeploymentResources resources;
    # A randomly-generated id of this Deployment
    string id;
};

# Defines configuration parameters that control how the plan (ie consisting of the cluster topology and AppSearch settings) is applied
public type TransientAppSearchPlanConfiguration record {
    @jsondata:Name {value: "plan_configuration"}
    AppSearchPlanControlConfiguration planConfiguration?;
    # The options for performing a plan change. Specify only one property each time. The default is `grow_and_shrink`
    PlanStrategy strategy?;
};

# This structure defines a curated subset of the AppSearch settings. (This field together with 'user_settings_override*' and  'user_settings*' defines the total set of AppSearch settings)
public type AppSearchSystemSettings record {
    # Optionally override the URL to which to send data (for advanced users only, if unspecified the system selects an internal URL)
    @jsondata:Name {value: "elasticsearch_url"}
    string elasticsearchUrl?;
    # Optionally override the secret session key within App Search - defaults to the previously existing secretSession. Note that this field is never returned from the API, it is write only
    @jsondata:Name {value: "secret_session_key"}
    string secretSessionKey?;
    # Optionally override the account within App Search - defaults to a system account that always exists (if specified, the username must also be specified). Note that this field is never returned from the API, it is write only
    @jsondata:Name {value: "elasticsearch_password"}
    string elasticsearchPassword?;
    # Optionally override the account within App Search - defaults to a system account that always exists (if specified, the password must also be specified). Note that this field is never returned from the API, it is write only
    @jsondata:Name {value: "elasticsearch_username"}
    string elasticsearchUsername?;
};

# Represents the Queries record for the operation: delete-organization-memberships
public type DeleteOrganizationMembershipsQueries record {
    # Whether or not to force the removal of Org memberships (effective only for Platform Admins)
    boolean force = false;
};

# The top level costs overview for an organization. All of the costs, credits, trials are expressed in Elastic Consumption Unit (ECU)
public type CostsOverview record {
    # Costs overview for an organization. All of the costs, credits, trials are expressed in Elastic Consumption Unit (ECU)
    Costs costs;
    # Trial costs for the organization
    decimal trials;
    # The available balance for an organization
    Balance balance?;
    # Hourly rate applied
    @jsondata:Name {value: "hourly_rate"}
    decimal hourlyRate;
};

# A collection of invitations to an organization
public type OrganizationInvitations record {
    # The list of organization invitations
    OrganizationInvitation[] invitations;
};

# The certificate authority used to sign the certificates of this deployment
public type CertificateAuthority record {
    # The certificates used by this certificate authority. The active certificate is the one that has been used to sign the current certificates of the Elasticsearch instances. All others are either certificates used in the past or certificates that will be used in the future when the currently active certificate expires
    @jsondata:Name {value: "public_certificates"}
    PublicCertificate[] publicCertificates;
    # The trust restriction expression to use that would provide trust with the Elasticsearch nodes of this deployment
    @jsondata:Name {value: "recommended_trust_restriction"}
    string recommendedTrustRestriction;
};

# A request to update an account
public type AccountUpdateRequest record {
    # Settings related to the level of trust of the clusters in this account
    AccountTrustSettings trust?;
};

# Represents the Queries record for the operation: get-traffic-filter-rulesets
public type GetTrafficFilterRulesetsQueries record {
    # Retrieves a list of resources that are associated to the specified ruleset
    @http:Query {name: "include_associations"}
    boolean includeAssociations = false;
    # Retrieves a list of resources that are associated to the specified organization ID. It only takes effect if the user is an admin
    @http:Query {name: "organization_id"}
    string organizationId?;
    # If provided limits the rulesets to that region only
    string region?;
};

# Provides API key configurations needed when communicating with a remote HTTP endpoint.
public type ApiKeysConfig record {|
    string authorization;
|};

# As part of the upgrade plan, identifies the move requests for the Kibana instances or APM Servers on the allocators
public type AllocatorMoveRequest record {
    # Tells the infrastructure that all instances on the allocator should be considered as permanently down when deciding how to migrate data to new nodes. If left blank then the system will auto-decide (currently: will treat the allocator as up)
    @jsondata:Name {value: "allocator_down"}
    boolean allocatorDown?;
    # The allocator id off which all instances in the cluster should be moved
    string 'from;
    # An optional list of allocator ids to which the instance(s) should be moved. If not specified then any available allocator can be used (including the current one if it is healthy)
    string[] to?;
};

# Assignment for a role with project scope
public type ProjectRoleAssignment record {
    # When true, the role applies to all projects in the organization, otherwise the role is scoped to the projects specified in `project_ids`
    boolean all?;
    # The ID of the role that is assigned
    @jsondata:Name {value: "role_id"}
    string roleId;
    # The ID of the organization the role is scoped to
    @jsondata:Name {value: "organization_id"}
    string organizationId;
    # If provided, the user assigned this role assignment will be granted this application role when signing in to the project(s) specified in the role assignment
    @jsondata:Name {value: "application_roles"}
    string[] applicationRoles?;
    # The IDs of the projects the role is scoped to. Must be absent if `all` is true, and present if `all` is false
    @jsondata:Name {value: "project_ids"}
    string[] projectIds?;
};

# Holds diagnostics for a Kibana resource
public type Kibana record {
    # A locally-unique user-specified id
    @jsondata:Name {value: "ref_id"}
    string refId;
    # The user-specified id of the Elasticsearch Cluster that this will link to
    @jsondata:Name {value: "elasticsearch_cluster_ref_id"}
    string elasticsearchClusterRefId;
    # The backend plan as JSON
    @jsondata:Name {value: "backend_plan"}
    record {} backendPlan;
    # The human readable name (defaults to the generated cluster id if not specified)
    @jsondata:Name {value: "display_name"}
    string displayName;
};

# An organization
public type Organization record {
    # The login identifier for initiating SSO
    @jsondata:Name {value: "sso_login_identifier"}
    string ssoLoginIdentifier?;
    # Whether the default disk alerts are enabled
    @jsondata:Name {value: "default_disk_usage_alerts_enabled"}
    boolean defaultDiskUsageAlertsEnabled?;
    # The organization's friendly name
    string name;
    # The list of allowed domains for notification-email recipients
    @jsondata:Name {value: "notifications_allowed_email_domains"}
    string[] notificationsAllowedEmailDomains?;
    # The list of contacts for billing notifications, if specified
    @jsondata:Name {value: "billing_contacts"}
    string[] billingContacts?;
    # The organization's identifier
    string id;
    # The list of contacts for operational notifications, if specified
    @jsondata:Name {value: "operational_contacts"}
    string[] operationalContacts?;
};

# Specifies the conditions to trigger an Elasticsearch cluster curation
public type ClusterCurationSpec record {
    # Number of seconds after index creation to trigger this spec
    @jsondata:Name {value: "trigger_interval_seconds"}
    int:Signed32 triggerIntervalSeconds;
    # Index matching pattern
    @jsondata:Name {value: "index_pattern"}
    string indexPattern;
};

# Holds diagnostics for an Integrations Server resource
public type IntegrationsServer record {
    # A locally-unique user-specified id
    @jsondata:Name {value: "ref_id"}
    string refId;
    # The user-specified id of the Elasticsearch Cluster that this will link to
    @jsondata:Name {value: "elasticsearch_cluster_ref_id"}
    string elasticsearchClusterRefId;
    # The backend plan as JSON
    @jsondata:Name {value: "backend_plan"}
    record {} backendPlan;
    # The human readable name (defaults to the generated cluster id if not specified)
    @jsondata:Name {value: "display_name"}
    string displayName;
};

# An index pattern described indicating how it has to be migrated to ILM
public type IndexPattern record {
    # Defines the Elasticsearch node attributes for the warm element of the topology
    @jsondata:Name {value: "node_attributes"}
    record {|string...;|} nodeAttributes?;
    # Name of the policy to create
    @jsondata:Name {value: "policy_name"}
    string policyName;
    # Index pattern to which the ILM policy will be applied
    @jsondata:Name {value: "index_pattern"}
    string indexPattern;
};

# Represents the Queries record for the operation: get-deployment-kib-resource-info
public type GetDeploymentKibResourceInfoQueries record {
    # Whether to include with the current and pending plan information the attempt log - can be very large per cluster
    @http:Query {name: "show_plan_logs"}
    boolean showPlanLogs = false;
    # Whether to include the full current and pending plan information in the response - can be large per cluster
    @http:Query {name: "show_plans"}
    boolean showPlans = true;
    # Whether to include the full cluster metadata in the response - can be large per cluster and also include credentials
    @http:Query {name: "show_metadata"}
    boolean showMetadata = false;
    # If showing plans, whether to leave pre-2.0.0 plans in their legacy format (the default), or whether to update them to 2.0.x+ format (if 'true')
    @http:Query {name: "convert_legacy_plans"}
    boolean convertLegacyPlans = false;
    # Whether to show cluster settings in the response
    @http:Query {name: "show_settings"}
    boolean showSettings = false;
    # Whether to include with the current and pending plan information the plan history- can be very large per cluster
    @http:Query {name: "show_plan_history"}
    boolean showPlanHistory = false;
    # If showing plans, whether to show values that are left at their default value (less readable but more informative)
    @http:Query {name: "show_plan_defaults"}
    boolean showPlanDefaults = false;
    # If set (defaults to false) then removes the transient section from all child resources, making it safe to reapply via an update
    @http:Query {name: "clear_transient"}
    boolean clearTransient = false;
};

public type VerificationCodeRequest record {
    # The domain claim request
    @jsondata:Name {value: "domain_claim_request"}
    string domainClaimRequest;
};

# A subset of Elasticsearch settings. TIP: To define the complete set of Elasticsearch settings, use `ElasticsearchSystemSettings` with `user_settings_override*` and `user_settings*`
public type ElasticsearchSystemSettings record {
    # Controls the languages supported by the Elasticsearch cluster, such as Painless, Mustache, and Expressions. Controls how the languages are used, such as file, index, and inline. TIP: For complex configurations, leave these blank and configure these settings in the user YAML or JSON
    ElasticsearchScriptingUserSettings scripting?;
    # Defaults to false on versions <= 7.2.0, true otherwise. If false, then the API commands to close indices are disabled. This is important because Elasticsearch does not snapshot or migrate close indices on versions under 7.2.0, therefore standard Elastic Cloud configuration operations will cause irretrievable loss of indices' data. NOTES: (Corresponds to the parameter 'cluster.indices.close.enable')
    @jsondata:Name {value: "enable_close_index"}
    boolean enableCloseIndex?;
    # Limits remote Elasticsearch clusters that can be used as the source for '_reindex' API commands
    @jsondata:Name {value: "reindex_whitelist"}
    string[] reindexWhitelist?;
    # The trigger engine for Watcher, defaults to 'scheduler' - see the xpack documentation for more information. NOTES: (Corresponds to the parameter '(xpack.)watcher.trigger.schedule.engine', depending on version. Ignored from 6.x onwards.)
    @jsondata:Name {value: "watcher_trigger_engine"}
    string watcherTriggerEngine?;
    # If true (the default), then any write operation on an index that does not currently exist will create it. NOTES: (Corresponds to the parameter 'action.auto_create_index')
    @jsondata:Name {value: "auto_create_index"}
    boolean autoCreateIndex?;
    # The default interval at which monitoring information from the cluster if collected, if monitoring is enabled. NOTES: (Corresponds to the parameter 'marvel.agent.interval' in 2.x and 'xpack.monitoring.collection.interval' in 5.x)
    @jsondata:Name {value: "monitoring_collection_interval"}
    int:Signed32 monitoringCollectionInterval?;
    # (2.x only - to get the same result in 5.x template mappings must be used) Sets the default number of shards per index, defaulting to 1 if not specified. (Corresponds to the parameter 'index.number_of_shards' in 2.x, not supported in 5.x)
    @jsondata:Name {value: "default_shards_per_index"}
    int:Signed32 defaultShardsPerIndex?;
    # The duration for which monitoring history is stored (format '(NUMBER)d' eg '3d' for 3 days). NOTES: ('Corresponds to the parameter xpack.monitoring.history.duration' in 5.x, defaults to '7d')
    @jsondata:Name {value: "monitoring_history_duration"}
    string monitoringHistoryDuration?;
    # If true (default is false) then the index deletion API will not support wildcards or '_all'. NOTES: (Corresponds to the parameter 'action.destructive_requires_name')
    @jsondata:Name {value: "destructive_requires_name"}
    boolean destructiveRequiresName?;
};

# Details about orphaned resources
public type Orphaned record {
    # List of orphaned Enterprise Search resource ids
    @jsondata:Name {value: "enterprise_search"}
    string[] enterpriseSearch;
    # List of orphaned Elasticsearch resources
    OrphanedElasticsearch[] elasticsearch;
    # List of orphaned Kibana resource ids
    string[] kibana;
    # List of orphaned APM resource ids
    string[] apm;
    # List of orphaned AppSearch resource ids
    string[] appsearch;
    # List of orphaned Integrations Server resource ids
    @jsondata:Name {value: "integrations_server"}
    string[] integrationsServer;
};

# Represents the Queries record for the operation: get-deployment-appsearch-resource-info
public type GetDeploymentAppsearchResourceInfoQueries record {
    # Whether to include with the current and pending plan information the attempt log - can be very large per cluster
    @http:Query {name: "show_plan_logs"}
    boolean showPlanLogs = false;
    # Whether to include the full current and pending plan information in the response - can be large per cluster
    @http:Query {name: "show_plans"}
    boolean showPlans = true;
    # Whether to include the full cluster metadata in the response - can be large per cluster and also include credentials
    @http:Query {name: "show_metadata"}
    boolean showMetadata = false;
    # Whether to show cluster settings in the response
    @http:Query {name: "show_settings"}
    boolean showSettings = false;
    # Whether to include with the current and pending plan information the plan history- can be very large per cluster
    @http:Query {name: "show_plan_history"}
    boolean showPlanHistory = false;
    # If showing plans, whether to show values that are left at their default value (less readable but more informative)
    @http:Query {name: "show_plan_defaults"}
    boolean showPlanDefaults = false;
    # If set (defaults to false) then removes the transient section from all child resources, making it safe to reapply via an update
    @http:Query {name: "clear_transient"}
    boolean clearTransient = false;
};

# A subset of Kibana settings. TIP: To define the complete set of Elasticsearch settings, use `KibanaSystemSettings` with `user_settings_override_` and `user_settings_`
public type KibanaSystemSettings record {
    # Optionally override the account within Elasticsearch - defaults to a system account that always exists (if specified, the username must also be specified). Note that this field is never returned from the API, it is write only
    @jsondata:Name {value: "elasticsearch_password"}
    string elasticsearchPassword?;
    # Optionally override the account within Elasticsearch - defaults to a system account that always exists (if specified, the password must also be specified). Note that this field is never returned from the API, it is write only
    @jsondata:Name {value: "elasticsearch_username"}
    string elasticsearchUsername?;
};

# Assignment for a role with platform scope
public type PlatformRoleAssignment record {
    # The ID of the role that is assigned
    @jsondata:Name {value: "role_id"}
    string roleId;
};

# A request to setup an organization IdP
public type IdpConfigurationRequest record {
    @jsondata:Name {value: "saml_idp"}
    SamlIdp samlIdp;
    # The prefix of the login identifier that will be generated
    @jsondata:Name {value: "login_identifier_prefix"}
    string loginIdentifierPrefix;
    # Whether or not the IdP is enabled
    boolean enabled;
};

# The details for multiple Elastic Stack configurations
public type StackVersionConfigs record {
    StackVersionConfig[] stacks;
};

# Represents the Queries record for the operation: get-version-stacks
public type GetVersionStacksQueries record {
    # Whether to show deleted stack versions or not
    @http:Query {name: "show_deleted"}
    boolean showDeleted = false;
    # Whether to show versions that are unusable by the authenticated user
    @http:Query {name: "show_unusable"}
    boolean showUnusable = false;
};

# Information about the use and storage capacity of a Kibana instance or APM Server
public type ClusterInstanceDiskInfo record {
    # The amount of disk space being used by the service in MB
    @jsondata:Name {value: "disk_space_used"}
    int diskSpaceUsed;
    # The storage multiplier originally defined to calculate disk space
    @jsondata:Name {value: "storage_multiplier"}
    decimal storageMultiplier;
    # If known, the amount of total disk space available to the container in MB
    @jsondata:Name {value: "disk_space_available"}
    int diskSpaceAvailable?;
};

# The information about an Elasticsearch cluster user
public type ElasticsearchClusterUser record {
    # The hashed password
    @jsondata:Name {value: "password_hash"}
    string passwordHash;
    # The username
    string username;
};

# Defines the topology of the Integrations Server nodes. For example, the number or capacity of the nodes, and where you can allocate the nodes
public type IntegrationsServerTopologyElement record {
    # Controls the allocation of this topology element as well as allowed sizes and node_types. It needs to match the id of an existing instance configuration
    @jsondata:Name {value: "instance_configuration_id"}
    string instanceConfigurationId?;
    # The version of the Instance Configuration Id. If it is unset, the meaning depends on read vs writes. For deployment reads, it is equivalent to version 0 (or the IC is unversioned); for deployment creates and deployment template use, it is equivalent to 'the latest version'; and for deployment updates, it is equivalent to 'retain the current version'
    @jsondata:Name {value: "instance_configuration_version"}
    int:Signed32 instanceConfigurationVersion?;
    # Measured by the amount of a resource. The final cluster size is calculated using multipliers from the topology instance configuration
    TopologySize size?;
    # number of zones in which nodes will be placed
    @jsondata:Name {value: "zone_count"}
    int:Signed32 zoneCount?;
    @jsondata:Name {value: "integrations_server"}
    IntegrationsServerConfiguration integrationsServer?;
};

# The Elasticsearch resource used as a Remote Cluster
public type RemoteResourceRef record {
    # If true, skip this cluster during search if it is disconnected. Default: false
    @jsondata:Name {value: "skip_unavailable"}
    boolean skipUnavailable?;
    # The alias for this remote cluster. Aliases must only contain letters, digits, dashes and underscores
    string alias;
    # The locally-unique user-specified id of an Elasticsearch Resource
    @jsondata:Name {value: "elasticsearch_ref_id"}
    string elasticsearchRefId;
    # The id of the deployment
    @jsondata:Name {value: "deployment_id"}
    string deploymentId;
    # Information about a Remote Cluster
    RemoteResourceInfo info?;
};

# A request to create or update an organization
public type OrganizationRequest record {
    # Whether the default disk alerts are enabled
    @jsondata:Name {value: "default_disk_usage_alerts_enabled"}
    boolean defaultDiskUsageAlertsEnabled?;
    # The organization's friendly name
    string name?;
    # The list of allowed domains for notification-email recipients
    @jsondata:Name {value: "notifications_allowed_email_domains"}
    string[] notificationsAllowedEmailDomains?;
    # The list of contacts for billing notifications
    @jsondata:Name {value: "billing_contacts"}
    string[] billingContacts?;
    # The list of contacts for operational notifications
    @jsondata:Name {value: "operational_contacts"}
    string[] operationalContacts?;
};

# Information about the snapshot status for the Elasticsearch cluster. For example, the health status
public type SnapshotStatusInfo record {
    # Health status of snapshots for this cluster
    boolean healthy;
    # The end time of the most recently successful snapshot
    @jsondata:Name {value: "latest_successful_end_time"}
    string latestSuccessfulEndTime?;
    # Indicates whether the cluster has a relatively recent successful snapshot
    @jsondata:Name {value: "recent_success"}
    boolean recentSuccess;
    # Number of snapshots stored for this cluster
    int:Signed32 count;
    # Latest snapshot status
    @jsondata:Name {value: "latest_successful"}
    boolean latestSuccessful?;
    # The end time of the most recently attempted snapshot
    @jsondata:Name {value: "latest_end_time"}
    string latestEndTime?;
    # Scheduled time of next snapshot attempt
    @jsondata:Name {value: "scheduled_time"}
    string scheduledTime?;
    # Status of the latest snapshot attempt, if any exist
    @jsondata:Name {value: "latest_status"}
    string latestStatus?;
};

# Read-only mode request payload
public type ReadOnlyRequest record {
    # Enabled or disabled read-only mode
    boolean enabled;
};

# Represents the Queries record for the operation: shutdown-deployment
public type ShutdownDeploymentQueries record {
    # Whether or not to hide the deployment and its resources.Only applicable for Platform administrators
    boolean hide?;
    # Whether or not to skip snapshots before shutting down the resources
    @http:Query {name: "skip_snapshot"}
    boolean skipSnapshot = false;
};

# Information about the ports that allow communication between the Elasticsearch cluster and various protocols
public type ClusterMetadataPortInfo record {
    # Port where the cluster listens for transport traffic using TLS
    @jsondata:Name {value: "transport_passthrough"}
    int:Signed32 transportPassthrough;
    # Port where the cluster listens for HTTP traffic
    int:Signed32 http;
    # Port where the cluster listens for HTTPS traffic
    int:Signed32 https;
};

# Controls for the topology element. Only used as part of the deployment template. Ignored if included as part of a deployment
public type TopologyElementControl record {
    # Measured by the amount of a resource. The final cluster size is calculated using multipliers from the topology instance configuration
    TopologySize min;
};

# An Integrations Server creation request paired with the alias of the Elasticsearch cluster it should be paired with
public type IntegrationsServerPayload record {
    # A locally-unique user-specified id for the Integrations Server
    @jsondata:Name {value: "ref_id"}
    string refId;
    # The settings for the Integrations Server
    IntegrationsServerSettings settings?;
    # Alias to the Elasticsearch Cluster to attach the Integrations Server to
    @jsondata:Name {value: "elasticsearch_cluster_ref_id"}
    string elasticsearchClusterRefId;
    # The human readable name for the Integrations Server cluster (default: takes the name of its Elasticsearch cluster)
    @jsondata:Name {value: "display_name"}
    string displayName?;
    # The region where this resource exists
    string region;
    # The plan for the Integrations Server
    IntegrationsServerPlan plan;
};

# A response returned from the Deployment restore endpoint
public type DeploymentRestoreResponse record {
    # The id of the deployment
    string id;
};

# DTS quantity
public type DtsQuantity record {
    # Raw quantity
    int value;
    # Quantity in human readable format
    @jsondata:Name {value: "formatted_value"}
    string formattedValue;
};

# Information about a Remote Cluster
public type RemoteResourceInfo record {
    # Whether or not there is at least one connection to the remote cluster
    boolean connected;
    # Whether or not the remote cluster version is compatible with this cluster version
    boolean compatible;
    # Whether or not the remote cluster is trusted by this cluster
    boolean trusted;
    # Whether or not the remote cluster is healthy
    boolean healthy;
    # Whether or not the remote cluster trusts this cluster back
    @jsondata:Name {value: "trusted_back"}
    boolean trustedBack;
};

# Billing dimension
public type Dimension record {
    # The cost of the billing dimension
    decimal cost;
    # The type of the billing dimension
    "capacity"|"data_in"|"data_internode"|"data_out"|"storage_api"|"storage_bytes" 'type;
};

# Information about the Elasticsearch cluster plan
public type ElasticsearchClusterPlanInfo record {
    # Either the plan ended successfully, or is not yet completed (and no errors have occurred)
    boolean healthy;
    ClusterPlanWarning[] warnings;
    # If this plan completed or failed (ie is not pending), when the attempt ended (ISO format in UTC)
    @jsondata:Name {value: "attempt_end_time"}
    string attemptEndTime?;
    # A container for information about the source of a change
    ChangeSourceInfo 'source?;
    # Information about an error during a plan attempt
    ClusterPlanAttemptError 'error?;
    # The plan for the Elasticsearch cluster
    ElasticsearchClusterPlan plan?;
    @jsondata:Name {value: "plan_attempt_log"}
    ClusterPlanStepInfo[] planAttemptLog;
    # If this plan is not current or pending, when the plan was no longer active (ISO format in UTC)
    @jsondata:Name {value: "plan_end_time"}
    string planEndTime?;
    # A UUID for each plan attempt
    @jsondata:Name {value: "plan_attempt_id"}
    string planAttemptId?;
    # A human readable name for each plan attempt, only populated when retrieving plan histories
    @jsondata:Name {value: "plan_attempt_name"}
    string planAttemptName?;
    # When this plan attempt (ie to apply the plan to the cluster) started (ISO format in UTC)
    @jsondata:Name {value: "attempt_start_time"}
    string attemptStartTime?;
};

# The top-level object information for a Kibana instance
public type KibanaClusterInfo record {
    # The name of the cluster
    @jsondata:Name {value: "cluster_name"}
    string clusterName;
    # The settings for multiple Kibana instances
    KibanaClusterSettings settings?;
    # Information about the public and internal state, and the configuration settings of an Elasticsearch cluster
    ClusterMetadataInfo metadata;
    # The topology for Elasticsearch clusters, multiple Kibana instances, or multiple APM Servers. The `ClusterTopologyInfo` also includes the instances and containers, and where they are located
    ClusterTopologyInfo topology;
    @jsondata:Name {value: "plan_info"}
    KibanaClusterPlansInfo planInfo;
    @jsondata:Name {value: "elasticsearch_cluster"}
    TargetElasticsearchCluster elasticsearchCluster;
    # The id of the cluster
    @jsondata:Name {value: "cluster_id"}
    string clusterId;
    # Whether the cluster is healthy or not (one or more of the info subsections will have healthy: false)
    boolean healthy;
    # External resources related to the cluster
    @jsondata:Name {value: "external_links"}
    ExternalHyperlink[] externalLinks;
    # A map of application-specific operations (which map to 'operationId's in the Swagger API) to metadata about that operation
    record {|Hyperlink...;|} links?;
    # The id of the deployment to which this Kibana Server belongs to
    @jsondata:Name {value: "deployment_id"}
    string deploymentId?;
    # The region that this cluster belongs to. Only populated in SaaS or federated ECE
    string region?;
    # Cluster status
    "initializing"|"stopping"|"stopped"|"rebooting"|"restarting"|"reconfiguring"|"started" status;
};

# The container for a set of traffic filter claimed link id
public type TrafficFilterClaimedLinkIds record {
    # List of traffic filter claimed link id
    @jsondata:Name {value: "claimed_link_ids"}
    TrafficFilterClaimedLinkIdInfo[] claimedLinkIds;
};

# Describes an Enterprise Search resource belonging to a Deployment
public type EnterpriseSearchResourceInfo record {
    # The locally-unique user-specified id of a Resource
    @jsondata:Name {value: "ref_id"}
    string refId;
    # The Elasticsearch cluster that this resource depends on
    @jsondata:Name {value: "elasticsearch_cluster_ref_id"}
    string elasticsearchClusterRefId;
    # The randomly-generated id of a Resource
    string id;
    # The region where this resource exists
    string region;
    # The overview information for the Enterprise Search Server
    EnterpriseSearchInfo info;
};

# The topology of the Kibana nodes, including the number, capacity, and type of nodes, and where they can be allocated
public type KibanaClusterTopologyElement record {
    # Controls the allocation of this topology element as well as allowed sizes and node_types. It needs to match the id of an existing instance configuration
    @jsondata:Name {value: "instance_configuration_id"}
    string instanceConfigurationId?;
    # The version of the Instance Configuration Id. If it is unset, the meaning depends on read vs writes. For deployment reads, it is equivalent to version 0 (or the IC is unversioned); for deployment creates and deployment template use, it is equivalent to 'the latest version'; and for deployment updates, it is equivalent to 'retain the current version'
    @jsondata:Name {value: "instance_configuration_version"}
    int:Signed32 instanceConfigurationVersion?;
    # Measured by the amount of a resource. The final cluster size is calculated using multipliers from the topology instance configuration
    TopologySize size?;
    # number of zones in which nodes will be placed
    @jsondata:Name {value: "zone_count"}
    int:Signed32 zoneCount?;
    # The Kibana instance settings. When specified at the top level, provides a field-by-field default. When specified at the topology level, provides the override settings
    KibanaConfiguration kibana?;
};

# Instance sizes that are supported by the Elasticsearch instance, Kibana instance, or APM Server configuration
public type DiscreteSizes record {
    # The default size
    @jsondata:Name {value: "default_size"}
    int:Signed32 defaultSize?;
    # List of supported sizes
    int:Signed32[] sizes;
    # The unit that each size represents. If not specified, it will default to 'memory'
    "memory"|"storage" 'resource?;
};

# Costs associated to a set of Elastic Cloud resources for an organization. All of the costs are expressed in Elastic Consumption Unit (ECU)
public type ItemsCosts record {
    # Costs overview for an organization. All of the costs, credits, trials are expressed in Elastic Consumption Unit (ECU)
    Costs costs;
    # List of the detailed costs associated to the Data Transfer and Storage (DTS) dimensions
    @jsondata:Name {value: "data_transfer_and_storage"}
    DtsDimensionCosts[] dataTransferAndStorage;
    # Costs of the list of resources
    ItemCosts[] resources;
};

# Represents the Queries record for the operation: get-deployment-integrations-server-resource-info
public type GetDeploymentIntegrationsServerResourceInfoQueries record {
    # Whether to include with the current and pending plan information the attempt log - can be very large per cluster
    @http:Query {name: "show_plan_logs"}
    boolean showPlanLogs = false;
    # Whether to include the full current and pending plan information in the response - can be large per cluster
    @http:Query {name: "show_plans"}
    boolean showPlans = true;
    # Whether to include the full cluster metadata in the response - can be large per cluster and also include credentials
    @http:Query {name: "show_metadata"}
    boolean showMetadata = false;
    # Whether to show cluster settings in the response
    @http:Query {name: "show_settings"}
    boolean showSettings = false;
    # Whether to include with the current and pending plan information the plan history- can be very large per cluster
    @http:Query {name: "show_plan_history"}
    boolean showPlanHistory = false;
    # If showing plans, whether to show values that are left at their default value (less readable but more informative)
    @http:Query {name: "show_plan_defaults"}
    boolean showPlanDefaults = false;
    # If set (defaults to false) then removes the transient section from all child resources, making it safe to reapply via an update
    @http:Query {name: "clear_transient"}
    boolean clearTransient = false;
};

# Information about the specified Elasticsearch cluster
public type TargetElasticsearchCluster record {
    # A map of application-specific operations (which map to 'operationId's in the Swagger API) to metadata about that operation
    record {|Hyperlink...;|} links?;
    # The Elasticsearch cluster Id
    @jsondata:Name {value: "elasticsearch_id"}
    string elasticsearchId;
};

# Information about the public and internal state, and the configuration settings of an Elasticsearch cluster
public type ClusterMetadataInfo record {
    # The full URL to access this deployment resource
    @jsondata:Name {value: "service_url"}
    string serviceUrl?;
    # The DNS name of the cluster endpoint, if available
    string endpoint?;
    # The DNS name of the cluster endpoint derived from the deployment alias, if available
    @jsondata:Name {value: "aliased_endpoint"}
    string aliasedEndpoint?;
    # The full aliased URL to access this deployment resource
    @jsondata:Name {value: "aliased_url"}
    string aliasedUrl?;
    # An unstructured JSON representation of the public and internal state (can be filtered out via URL parameter). The contents and structure of the `raw` field can change at any time. 
    record {} raw?;
    # The cloud ID, an encoded string that provides other Elastic services with the necessary information to connect to this Elasticsearch and Kibana (only present if both exist)
    @jsondata:Name {value: "cloud_id"}
    string cloudId?;
    # A list of the URLs to access services that the resource provides at this time. Note that if the service is not running or has not started yet, the URL to access it won't be available
    @jsondata:Name {value: "services_urls"}
    ServiceUrl[] servicesUrls?;
    # Information about the ports that allow communication between the Elasticsearch cluster and various protocols
    ClusterMetadataPortInfo ports?;
    # The resource version number of the cluster metadata
    int:Signed32 version;
    # The most recent time the cluster metadata was changed (ISO format in UTC)
    @jsondata:Name {value: "last_modified"}
    string lastModified;
};

# Represents the Queries record for the operation: get-extension
public type GetExtensionQueries record {
    # Include deployments referencing this extension. Up to only 10000 deployments will be included
    @http:Query {name: "include_deployments"}
    boolean includeDeployments = false;
};

# The key-value pair
public type MetadataItem record {
    # The metadata value
    string value;
    # The metadata field name
    string 'key;
};

# The trust relationship with entities trusted directly having their certificate bundled together with the trust settings
public type DirectTrustRelationship record {
    # Auto generated identifier for this trust, allows distinguishing between update vs remove and add
    string uid?;
    # A list of node names trusted in addition to those deducible from trust_allowlist and scope id. Allows trusting nodes that don't have a scoped name at the cost of maintaining the list. Mandatory if scope id is not defined. Wildcards are not allowed
    @jsondata:Name {value: "additional_node_names"}
    string[] additionalNodeNames?;
    # The public ca certificate(s) to trust. Only one is required, but it is possible to specify multiple certificates in order to facilitate key rotation
    TrustedCertificate[] certificates;
    # A lowercase alphanumerical string of max 32 characters. Usually an organization id or an environment id, but could really be any suitable suffix for clusters using the CA certificate of this trust. Required unless trust_all is false and trust_allowlist is empty
    @jsondata:Name {value: "scope_id"}
    string scopeId?;
    # If true, scope_id is required and the `trust_allowlist` is ignored and all clusters matching the scope id will be trusted
    @jsondata:Name {value: "trust_all"}
    boolean trustAll;
    # a human readable name of the trust relationship
    string name;
    # The list of clusters with matching scope to trust. Only used when `trust_all` is false. Providing one or more clusters makes scope_id mandatory
    @jsondata:Name {value: "trust_allowlist"}
    string[] trustAllowlist?;
    # The type can either be ESS, ECE, generic or proxy. If none is specified, then generic is assumed. If proxy is specified, trust_all should be false and trust_allowlist, scope_id and additional_node_names should be omitted
    "ECE"|"ESS"|"generic"|"proxy" 'type?;
};

# The settings for sending monitoring information to another cluster
public type ManagedMonitoringSettings record {
    # The Id of the target cluster to which to send monitoring information
    @jsondata:Name {value: "target_cluster_id"}
    string targetClusterId;
};

# Information about current, pending, and past App Search Server plans
public type AppSearchPlansInfo record {
    # Information about the App Search Server plan
    AppSearchPlanInfo current?;
    # Whether the plan situation is healthy (if unhealthy, means the last plan attempt failed)
    boolean healthy;
    # Information about the App Search Server plan
    AppSearchPlanInfo pending?;
    AppSearchPlanInfo[] history;
};

# This structure defines a curated subset of the Enterprise Search settings. (This field together with 'user_settings_override*' and  'user_settings*' defines the total set of Enterprise Search settings)
public type EnterpriseSearchSystemSettings record {
    # Optionally override the secret session key within Enterprise Search - defaults to the previously existing secretSession. Note that this field is never returned from the API, it is write only
    @jsondata:Name {value: "secret_session_key"}
    string secretSessionKey?;
    # Optionally override the account within Enterprise Search - defaults to a system account that always exists (if specified, the username must also be specified). Note that this field is never returned from the API, it is write only
    @jsondata:Name {value: "elasticsearch_password"}
    string elasticsearchPassword?;
    # Optionally override the account within Enterprise Search - defaults to a system account that always exists (if specified, the password must also be specified). Note that this field is never returned from the API, it is write only
    @jsondata:Name {value: "elasticsearch_username"}
    string elasticsearchUsername?;
};

# Information about the Elasticsearch cluster
public type ElasticsearchInfo record {
    @jsondata:Name {value: "cluster_blocking_issues"}
    ElasticsearchBlockingIssues clusterBlockingIssues?;
    @jsondata:Name {value: "blocking_issues"}
    ElasticsearchClusterBlockingIssues blockingIssues;
    # Whether the Elasticsearch cluster is healthy (check the sub-objects for more details if not)
    boolean healthy;
    @jsondata:Name {value: "shard_info"}
    ElasticsearchShardsInfo shardInfo;
    @jsondata:Name {value: "shards_status"}
    ElasticsearchShardsStatus shardsStatus?;
    @jsondata:Name {value: "master_info"}
    ElasticsearchMasterInfo masterInfo;
};

# Controls the languages supported by the Elasticsearch cluster, such as Painless, Mustache, and Expressions. Controls how the languages are used, such as file, index, and inline. TIP: For complex configurations, leave these blank and configure these settings in the user YAML or JSON
public type ElasticsearchScriptingUserSettings record {
    # (5.x+ only) If enabled (the default) then the mustache scripting engine is allowed as a sandboxed language. Sandboxed languages are the only ones allowed if 'sandbox_mode' is set to true. NOTES: (Corresponds to the parameters 'script.engine.mustache.[file|stored|inline]')
    @jsondata:Name {value: "mustache_enabled"}
    boolean mustacheEnabled?;
    # Enables scripting for the specified type and controls other parameters. Store scripts in indexes (`stored`), upload in file bundles (`file`), or use in API requests (`inline`)
    ElasticsearchScriptTypeSettings file?;
    # Enables scripting for the specified type and controls other parameters. Store scripts in indexes (`stored`), upload in file bundles (`file`), or use in API requests (`inline`)
    ElasticsearchScriptTypeSettings inline?;
    # Enables scripting for the specified type and controls other parameters. Store scripts in indexes (`stored`), upload in file bundles (`file`), or use in API requests (`inline`)
    ElasticsearchScriptTypeSettings stored?;
    # (5.x+ only) If enabled (the default) then the expressions scripting engine is allowed as a sandboxed language. Sandboxed languages are the only ones allowed if 'sandbox_mode' is set to true. NOTES: (Corresponds to the parameters 'script.engine.expression.[file|stored|inline]')
    @jsondata:Name {value: "expressions_enabled"}
    boolean expressionsEnabled?;
    # (5.x+ only) If enabled (the default) then the painless scripting engine is allowed as a sandboxed language. Sandboxed languages are the only ones allowed if 'sandbox_mode' is set to true. NOTES: (Corresponds to the parameters 'script.engine.painless.[file|stored|inline]')
    @jsondata:Name {value: "painless_enabled"}
    boolean painlessEnabled?;
};

# The metadata for the Elastic Stack
public type StackVersionMetadata record {
    # The schema version of the stack pack version
    @jsondata:Name {value: "schema_version"}
    int:Signed32 schemaVersion?;
    # Notes for administrator
    string notes?;
    # The minimum version of the platform that the stack pack version is compatible with
    @jsondata:Name {value: "min_platform_version"}
    string minPlatformVersion?;
    # Indicates that the stack pack version is not GA and is not supposed to be used in production
    @jsondata:Name {value: "pre_release"}
    boolean preRelease?;
    # The minimum version required for performing a rolling upgrade to this stack version
    @jsondata:Name {value: "min_wire_compatibility_version"}
    string minWireCompatibilityVersion?;
    # The minimum version required for performing a full cluster restart upgrade to this stack version
    @jsondata:Name {value: "min_index_compatibility_version"}
    string minIndexCompatibilityVersion?;
};

# Represents the Queries record for the operation: get-costs-overview
public type GetCostsOverviewQueries record {
    # A datetime for the beginning of the desired range for which to fetch costs. Defaults to start of current month
    string 'from?;
    # A datetime for the end of the desired range for which to fetch costs. Defaults to the current date
    string to?;
};

# Holds diagnostics for existing resources that might be updated
public type Updates record {
    # Diagnostics for Enterprise Search resources
    @jsondata:Name {value: "enterprise_search"}
    EnterpriseSearch[] enterpriseSearch?;
    # Diagnostics for Elasticsearch clusters
    Elasticsearch[] elasticsearch?;
    # Diagnostics for Kibanas
    Kibana[] kibana?;
    # Diagnostics for APMs
    Apm[] apm?;
    # Diagnostics for Integrations Server
    @jsondata:Name {value: "integrations_server"}
    IntegrationsServer[] integrationsServer?;
    # Diagnostics for AppSearches
    AppSearch[] appsearch?;
};

# Measured by the amount of a resource. The final cluster size is calculated using multipliers from the topology instance configuration
public type TopologySize record {
    # Type of resource. In ESS the resource used should always be `memory`
    "memory"|"storage" 'resource;
    # Amount of resource
    int:Signed32 value;
};

# The settings for the Enterprise Search
public type EnterpriseSearchSettings record {
    # The top-level configuration settings for the Elasticsearch cluster
    ClusterMetadataSettings metadata?;
};

public type TrafficFilterClaimedLinkIdInfo record {
    # Resource GUID of the Azure Private Endpoint to allow connections from
    @jsondata:Name {value: "azure_endpoint_guid"}
    string azureEndpointGuid?;
    # Name of the Azure Private Endpoint to allow connections from
    @jsondata:Name {value: "azure_endpoint_name"}
    string azureEndpointName?;
    # The claimed link id can be used only for traffic filter in the specific region
    string region;
    # Link id. A GCP private service connect ID or AWS VPC endpoint ID
    @jsondata:Name {value: "link_id"}
    string linkId?;
};

public type DomainVerificationRequest record {
    # The domain claim request
    @jsondata:Name {value: "domain_claim_request"}
    string domainClaimRequest;
};

# The Elasticsearch configuration for an Elastic Stack version. 
public type StackVersionElasticsearchConfig record {
    @jsondata:Name {value: "capacity_constraints"}
    StackVersionInstanceCapacityConstraint capacityConstraints?;
    # Node types that are supported by this stack version
    @jsondata:Name {value: "node_types"}
    StackVersionNodeType[] nodeTypes?;
    # Settings that are applied to all nodes of this type
    record {} settings?;
    # Node types that are compatible with this one
    @jsondata:Name {value: "compatible_node_types"}
    string[] compatibleNodeTypes?;
    # List of available plugins
    string[] plugins;
    # List of default plugins
    @jsondata:Name {value: "default_plugins"}
    string[] defaultPlugins;
    # List of configuration options that cannot be overridden by user settings
    string[] blacklist;
    # Docker image for the Elasticsearch
    @jsondata:Name {value: "docker_image"}
    string dockerImage;
};

# The value that you configure for the Elasticsearch keystore secret
public type KeystoreSecret record {
    # Value of this setting. This can either be a string or a JSON object that is stored as a JSON string in the keystore. NOTE: When the keystore secret is unspecified, it is removed
    record {} value?;
    # Stores the keystore secret as a file. The default is false, which stores the keystore secret as string when value is a plain string, or true when value is an object
    @jsondata:Name {value: "as_file"}
    boolean asFile?;
};

# Holds diagnostics for an Enterprise Search resource
public type EnterpriseSearch record {
    # A locally-unique user-specified id
    @jsondata:Name {value: "ref_id"}
    string refId;
    # The user-specified id of the Elasticsearch Cluster that this will link to
    @jsondata:Name {value: "elasticsearch_cluster_ref_id"}
    string elasticsearchClusterRefId;
    # The backend plan as JSON
    @jsondata:Name {value: "backend_plan"}
    record {} backendPlan;
    # The human readable name (defaults to the generated cluster id if not specified)
    @jsondata:Name {value: "display_name"}
    string displayName;
};

# Deployment template detailed information
public type DeploymentTemplateInfoV2 record {
    # Minimum stack version required by this template, if any
    @jsondata:Name {value: "min_version"}
    string minVersion?;
    # Whether or not if this is system owned template
    @jsondata:Name {value: "system_owned"}
    boolean systemOwned?;
    # The Kibana Deeplink for this type of deployment
    @jsondata:Name {value: "kibana_deeplink"}
    KibanaDeeplink[] kibanaDeeplink?;
    # Optional arbitrary metadata to associate with this template
    MetadataItem[] metadata?;
    # A human readable name for the template
    string name;
    # An optional description for the template
    string description?;
    # Provider and version agnostic template identifier used for grouping related template types
    @jsondata:Name {value: "template_category_id"}
    string templateCategoryId?;
    # The unique identifier for the template
    string id;
    # A container for information about the source of a change
    ChangeSourceInfo 'source?;
    # List of instance configurations used in the cluster template
    @jsondata:Name {value: "instance_configurations"}
    InstanceConfigurationInfo[] instanceConfigurations;
    @jsondata:Name {value: "deployment_template"}
    DeploymentCreateRequest deploymentTemplate;
    # Determines the order in which this template should be returned when listed. Templates are returned in ascending order. If not specified, then the template willbe appended to the end of the list
    int:Signed32 'order?;
};

# Read-only mode response
public type ReadOnlyResponse record {
    # Whether read-only mode is enabled or disabled
    boolean enabled;
};

# The settings for an Elasticsearch cluster
public type ElasticsearchClusterSettings record {
    # Configuration of trust with other clusters
    ElasticsearchClusterTrustSettings trust?;
    # The top-level configuration settings for the Elasticsearch cluster
    ClusterMetadataSettings metadata?;
    @jsondata:Name {value: "traffic_filter"}
    TrafficFilterSettings trafficFilter?;
    # The index curation settings for an Elasticsearch cluster
    ClusterCurationSettings curation?;
    @jsondata:Name {value: "keystore_contents"}
    KeystoreContents keystoreContents?;
    # The settings for sending monitoring information to another cluster
    ManagedMonitoringSettings monitoring?;
    # The snapshot configuration settings for an Elasticsearch cluster
    ClusterSnapshotSettings snapshot?;
    # Threshold starting from which the number of instances in the cluster results in the introduction of dedicated masters. If the cluster is downscaled to a number of nodes below this one, dedicated masters will be removed. Limit is inclusive. When provided the threshold setting is updated. A `null` value removes the field. Otherwise, the setting remains as it was set previously
    @jsondata:Name {value: "dedicated_masters_threshold"}
    int:Signed32 dedicatedMastersThreshold?;
};

# Controls the combinations of Elasticsearch node types. TIP: By default, the Elasticsearch node is master eligible, can hold data, and run ingest pipelines. WARNING: Do not set for tiebreaker topologies
public type ElasticsearchNodeType record {
    # Defines whether this node can hold data (default: false)
    boolean data?;
    # Defines whether this node can be elected master (default: false)
    boolean master?;
    # Defines whether this node can run an ingest pipeline (default: false)
    boolean ingest?;
    # Defines whether this node can run ml jobs, valid only for versions 5.4.0 or greater (default: false)
    boolean ml?;
};

public type InstanceOverrides record {
    # Overrides the disk quota multiplier for the instance
    @jsondata:Name {value: "storage_multiplier"}
    decimal storageMultiplier?;
    # Sets the memory capacity for the instances container. Requires a restart to take effect
    int:Signed32 capacity?;
};

# Information about the Elasticsearch instances. For split-brain cases, this also includes sub-clusters
public type ElasticsearchMasterElement record {
    # The names of the instance/container hosting the node belong to the cluster with the given master
    string[] instances;
    # The Elasticsearch node id of a master node
    @jsondata:Name {value: "master_node_id"}
    string masterNodeId;
    # The corresponding instance name of the container hosting the Elasticsearch master node, if available
    @jsondata:Name {value: "master_instance_name"}
    string masterInstanceName?;
};

# The container for a traffic filter rule
public type TrafficFilterRule record {
    # The remote cluster ID
    @jsondata:Name {value: "remote_cluster_id"}
    string remoteClusterId?;
    @jsondata:Name {value: "egress_rule"}
    TrafficFilterEgressRule egressRule?;
    # Resource GUID of the Azure Private Endpoint to allow connections from
    @jsondata:Name {value: "azure_endpoint_guid"}
    string azureEndpointGuid?;
    # Description of the rule
    string description?;
    # The rule ID
    string id?;
    # Allowed traffic filter source: IP address, CIDR mask, or VPC endpoint ID
    string 'source?;
    # Name of the Azure Private Endpoint to allow connections from
    @jsondata:Name {value: "azure_endpoint_name"}
    string azureEndpointName?;
    # The remote cluster organization ID
    @jsondata:Name {value: "remote_cluster_org_id"}
    string remoteClusterOrgId?;
};

# The information for an Elasticsearch cluster
public type ElasticsearchClusterInfo record {
    # The name of the cluster
    @jsondata:Name {value: "cluster_name"}
    string clusterName;
    @jsondata:Name {value: "associated_kibana_clusters"}
    KibanaSubClusterInfo[] associatedKibanaClusters;
    # The settings for an Elasticsearch cluster
    ElasticsearchClusterSettings settings?;
    # Information about the public and internal state, and the configuration settings of an Elasticsearch cluster
    ClusterMetadataInfo metadata;
    @jsondata:Name {value: "associated_apm_clusters"}
    ApmSubInfo[] associatedApmClusters;
    # The topology for Elasticsearch clusters, multiple Kibana instances, or multiple APM Servers. The `ClusterTopologyInfo` also includes the instances and containers, and where they are located
    ClusterTopologyInfo topology;
    @jsondata:Name {value: "associated_appsearch_clusters"}
    AppSearchSubInfo[] associatedAppsearchClusters;
    @jsondata:Name {value: "plan_info"}
    ElasticsearchClusterPlansInfo planInfo;
    # List of cluster system alerts
    @jsondata:Name {value: "system_alerts"}
    ClusterSystemAlert[] systemAlerts?;
    # Information about the snapshot status for the Elasticsearch cluster. For example, the health status
    SnapshotStatusInfo snapshots;
    # The id of the cluster
    @jsondata:Name {value: "cluster_id"}
    string clusterId;
    # For 2.x Elasticsearch clusters, specifies the information about the users and roles. For 5.x Elasticsearch clusters, use the Kibana management UI
    ElasticsearchClusterSecurityInfo security?;
    # Information about the Elasticsearch cluster
    ElasticsearchInfo elasticsearch;
    @jsondata:Name {value: "elasticsearch_monitoring_info"}
    ElasticsearchMonitoringInfo elasticsearchMonitoringInfo?;
    # Whether the cluster is healthy or not (one or more of the info subsections will have healthy: false)
    boolean healthy;
    # External resources related to the cluster
    @jsondata:Name {value: "external_links"}
    ExternalHyperlink[] externalLinks;
    @jsondata:Name {value: "associated_enterprise_search_clusters"}
    EnterpriseSearchSubInfo[] associatedEnterpriseSearchClusters;
    # A map of application-specific operations (which map to 'operationId's in the Swagger API) to metadata about that operation
    record {|Hyperlink...;|} links?;
    # The id of the deployment that this Elasticsearch belongs to
    @jsondata:Name {value: "deployment_id"}
    string deploymentId?;
    # The region that this cluster belongs to. Only populated in SaaS or federated ECE
    string region?;
    # Cluster status
    "initializing"|"stopping"|"stopped"|"rebooting"|"restarting"|"reconfiguring"|"started" status;
};

# Request sent to enable ILM on a deployment
public type EnableIlmRequest record {
    # A locally-unique user-specified id for Kibana
    @jsondata:Name {value: "index_patterns"}
    IndexPattern[] indexPatterns;
};

# Period
public type Period record {
    # Start
    string 'start;
    # End
    string end;
};

# A list of admin-uploaded bundle objects, such as scripts and synonym files
public type ElasticsearchUserBundle record {
    # The supported Elasticsearch version (must match the version in the plan)
    @jsondata:Name {value: "elasticsearch_version"}
    string elasticsearchVersion;
    # The name of the bundle
    string name;
    # The URL of the bundle, which must be accessible from the ECE infrastructure. This URL could be cached by platform, make sure to change it when updating the bundle
    string url;
};

# Information about the APM Servers associated with the Elasticsearch cluster
public type EnterpriseSearchSubInfo record {
    # A map of application-specific operations (which map to 'operationId's in the Swagger API) to metadata about that operation
    record {|Hyperlink...;|} links?;
    # The Enterprise Search Id
    @jsondata:Name {value: "enterprise_search_id"}
    string enterpriseSearchId;
    # Whether the associated Enterprise Search is currently available
    boolean enabled;
};

public type RoleMapping record {
    @jsondata:Name {value: "role_assignments"}
    RoleAssignments roleAssignments;
    # The name of the role mapping
    string name;
    RoleMappingRule rule;
    # Whether or not the role mapping is enabled
    boolean enabled;
};

# The logging settings for a deployment
public type DeploymentLoggingSettings record {
    # The destination to send logs and metrics to
    ObservabilityAbsoluteDeployment destination;
};

# Describes the diagnostics for a given Deployment-modifying payload
public type DeploymentDiagnostics record {
    # Holds diagnostics for resources that will be created
    Creates creates?;
    # Holds diagnostics for existing resources that might be updated
    Updates updates?;
};

# Roles assigned to users, API keys or organization invitations. Currently unavailable in self-hosted ECE
public type RoleAssignments record {
    # Assignments for roles with organization scope
    OrganizationRoleAssignment[] organization?;
    # Assignments for roles with project scope
    ProjectRoleAssignments project?;
    # Assignments for roles with platform scope
    PlatformRoleAssignment[] platform?;
    # Assignments for roles with deployment scope
    DeploymentRoleAssignment[] deployment?;
};

# A query that uses the strict query string syntax for parsing. Will return an error for invalid syntax
public type QueryStringQuery record {
    # The default operator used if no explicit operator is specified
    @jsondata:Name {value: "default_operator"}
    string defaultOperator?;
    # The analyzer used to analyze each term of the query when creating composite queries
    string analyzer?;
    # The actual query to be parsed
    string query;
    # The default field for query terms if no prefix field is specified
    @jsondata:Name {value: "default_field"}
    string defaultField?;
    # When set, * or ? are allowed as the first character. Defaults to false
    @jsondata:Name {value: "allow_leading_wildcard"}
    boolean allowLeadingWildcard?;
};

# A container for information about the source of a change
public type ChangeSourceInfo record {
    # The time the change was initiated
    string date;
    # The user that requested the change
    @jsondata:Name {value: "user_id"}
    string userId?;
    # The host addresses of the user that originated the change
    @jsondata:Name {value: "remote_addresses"}
    string[] remoteAddresses?;
    # The admin user that requested the change
    @jsondata:Name {value: "admin_id"}
    string adminId?;
    # The type of plan change that was initiated
    string action;
    # The service where the change originated from
    string facilitator;
};

# Represents the Queries record for the operation: shutdown-deployment-stateless-resource
public type ShutdownDeploymentStatelessResourceQueries record {
    # Hide cluster on shutdown. Hidden clusters are not listed by default. Only applicable for Platform administrators
    boolean hide?;
    # If true, will skip taking a snapshot of the cluster before shutting the cluster down (if even possible)
    @http:Query {name: "skip_snapshot"}
    boolean skipSnapshot = false;
};

# An alias for an Elasticsearch Cluster paired with a request for creating one
public type ElasticsearchPayload record {
    # A locally-unique user-specified id for this Elasticsearch cluster
    @jsondata:Name {value: "ref_id"}
    string refId;
    # The settings for an Elasticsearch cluster
    ElasticsearchClusterSettings settings?;
    # The human readable name for the cluster (defaults to the generated cluster id if not specified)
    @jsondata:Name {value: "display_name"}
    string displayName?;
    # The region where this resource exists
    string region;
    # The plan for the Elasticsearch cluster
    ElasticsearchClusterPlan plan;
};

public type DeploymentsListingData record {
    # The name of this deployment
    string name;
    # List of resources in this deployment
    DeploymentResource[] resources;
    # The id of this deployment
    string id;
};

# The Elasticsearch cluster settings. When specified at the top level, provides a field-by-field default. When specified at the topology level, provides the override settings
public type ElasticsearchConfiguration record {
    # An arbitrary JSON object allowing cluster owners to set their parameters (only one of this and 'user_settings_yaml' is allowed), provided the parameters arey are on the allowlist and not on the denylist. NOTES: (This field together with 'user_settings_override*' and 'system_settings' defines the total set of Elasticsearch settings)
    @jsondata:Name {value: "user_settings_json"}
    record {} userSettingsJson?;
    @jsondata:Name {value: "system_settings"}
    ElasticsearchSystemSettings systemSettings?;
    # An arbitrary YAML object allowing cluster owners to set their parameters (only one of this and 'user_settings_json' is allowed), provided the parameters arey are on the allowlist and not on the denylist. NOTES: (This field together with 'user_settings_override*' and 'system_settings' defines the total set of Elasticsearch settings)
    @jsondata:Name {value: "user_settings_yaml"}
    string userSettingsYaml?;
    # An arbitrary JSON object allowing ECE admins owners to set clusters' parameters (only one of this and 'user_settings_override_yaml' is allowed), ie in addition to the documented 'system_settings'. NOTES: (This field together with 'system_settings' and 'user_settings*' defines the total set of Elasticsearch settings)
    @jsondata:Name {value: "user_settings_override_json"}
    record {} userSettingsOverrideJson?;
    # A list of plugin names from the Elastic-supported subset that are bundled with the version images. NOTES: (Users should consult the Elastic stack objects to see what plugins are available, this is currently only available from the UI)
    @jsondata:Name {value: "enabled_built_in_plugins"}
    string[] enabledBuiltInPlugins?;
    # The structure that defines the routing settings for index curation
    ElasticsearchCuration curation?;
    # Defines the Elasticsearch node attributes for the instances in the topology
    @jsondata:Name {value: "node_attributes"}
    record {|string...;|} nodeAttributes?;
    # A list of admin-uploaded plugin objects that are available for this user
    @jsondata:Name {value: "user_plugins"}
    ElasticsearchUserPlugin[] userPlugins?;
    # A list of admin-uploaded bundle objects (eg scripts, synonym files) that are available for this user
    @jsondata:Name {value: "user_bundles"}
    ElasticsearchUserBundle[] userBundles?;
    # The version of the Elasticsearch cluster (must be one of the ECE supported versions). Currently cannot be different across the topology (and is generally specified in the globals). Defaults to the latest version if not specified
    string version?;
    # A docker URI that allows overriding of the default docker image specified for this version
    @jsondata:Name {value: "docker_image"}
    string dockerImage?;
    # An arbitrary YAML object allowing ECE admins owners to set clusters' parameters (only one of this and 'user_settings_override_json' is allowed), ie in addition to the documented 'system_settings'. NOTES: (This field together with 'system_settings' and 'user_settings*' defines the total set of Elasticsearch settings)
    @jsondata:Name {value: "user_settings_override_yaml"}
    string userSettingsOverrideYaml?;
};

# The metrics settings for a deployment
public type DeploymentMetricsSettings record {
    # The destination to send logs and metrics to
    ObservabilityAbsoluteDeployment destination;
};

# The response after you create a new ruleset
public type TrafficFilterRulesetResponse record {
    # The new ruleset ID
    string id;
};

# An account is the entity that owns deployments, and it is accessed by users. Accounts are isolated from each other
public type AccountResponse record {
    # Settings related to the level of trust of the clusters in this account
    AccountTrustSettings trust?;
    # The account's identifier
    string id;
};

public type ExtensionFileMetadata record {
    # The extension file size in bytes
    int size?;
    # The date and time the extension was last modified
    @jsondata:Name {value: "last_modified_date"}
    string lastModifiedDate?;
    # The temporary URL to download the extension file. Usable for verification
    string url?;
};

# The available balance for an organization
public type Balance record {
    # Available balance
    decimal available;
    # A collection of order line items for for an organization
    @jsondata:Name {value: "line_items"}
    SimplifiedLineItem[] lineItems;
    # Remaining balance
    decimal remaining;
};

public type EmptyResponse record {
};

# A query that matches all documents
public type MatchAllQuery record {
};

# Node types to enable for an Enterprise Search instance
public type EnterpriseSearchNodeTypes record {
    # Defines whether this instance should run as Connector
    boolean connector;
    # Defines whether this instance should run as Application/API server
    boolean appserver;
    # Defines whether this instance should run as background worker
    boolean 'worker;
};

public type DeleteDomainClaimRequest record {
    # The request to remove a domain claim
    @jsondata:Name {value: "domain_claim_request"}
    string domainClaimRequest;
};

# The username and password for the new Elasticsearch cluster, which is returned from the Elasticsearch cluster `create` command
public type ClusterCredentials record {
    # The password of the newly created cluster
    string password;
    # The username of the newly created cluster
    string username;
};

# The organization's IdP info
public type OrganizationIdp record {
    # The SAML2 assertion consumer service of the SP
    string acs;
    # The SAML2 metadata url for downloading the SAML2 SP metadata XML
    @jsondata:Name {value: "metadata_url"}
    string metadataUrl;
    # The organization's IdP configuration
    OrganizationIdpConfiguration configuration;
    # The Elastic Cloud login URL for this IdP
    @jsondata:Name {value: "sso_login_url"}
    string ssoLoginUrl;
    # The login identifier that is unique to this organization
    @jsondata:Name {value: "login_identifier"}
    string loginIdentifier;
    # The SP entity ID and the audience for SAML2 response assertions
    @jsondata:Name {value: "sp_entity_id"}
    string spEntityId;
    # The certificate that will sign SAML2 requests to the IdP
    @jsondata:Name {value: "signing_certificate"}
    string[] signingCertificate;
};

# The template information for an Elastic Stack version
public type StackVersionTemplateInfo record {
    # Template version
    @jsondata:Name {value: "template_version"}
    string templateVersion?;
    # Relative paths of files with SHA-256 hashes that contains the template
    StackVersionTemplateFileHash[] hashes?;
};

# Specifies the deployment template used to create the plan
public type DeploymentTemplateReference record {
    # The unique identifier of the deployment template
    string id;
    # A version identifier to disambiguate multiple revisions of the same template
    string version?;
};

# Information about the specific instances memory capacity and its usage
public type ClusterInstanceMemoryInfo record {
    # The planned memory capacity in MB of the instance (only shown when an override is present)
    @jsondata:Name {value: "instance_capacity_planned"}
    int:Signed32 instanceCapacityPlanned?;
    # The memory capacity in MB of the instance
    @jsondata:Name {value: "instance_capacity"}
    int:Signed32 instanceCapacity;
    # The % memory pressure of Elasticsearch JVM heap space if available (60-75% consider increasing capacity, >75% can incur significant performance and stability issues)
    @jsondata:Name {value: "memory_pressure"}
    int:Signed32 memoryPressure?;
    # The % memory pressure of the instance Docker container (if available)
    @jsondata:Name {value: "native_memory_pressure"}
    int:Signed32 nativeMemoryPressure?;
};

# Costs overview for an organization. All of the costs, credits, trials are expressed in Elastic Consumption Unit (ECU)
public type Costs record {
    # Total costs
    decimal total;
    # A collection of billing details by dimension
    Dimension[] dimensions;
};

# The topology of the Elasticsearch nodes, including the number, capacity, and type of nodes, and where they can be allocated
public type ElasticsearchClusterTopologyElement record {
    # Controls the allocation of this topology element as well as allowed sizes and node_types. It needs to match the id of an existing instance configuration
    @jsondata:Name {value: "instance_configuration_id"}
    string instanceConfigurationId?;
    @jsondata:Name {value: "autoscaling_max"}
    TopologySize autoscalingMax?;
    # The version of the Instance Configuration Id. If it is unset, the meaning depends on read vs writes. For deployment reads, it is equivalent to version 0 (or the IC is unversioned); for deployment creates and deployment template use, it is equivalent to 'the latest version'; and for deployment updates, it is equivalent to 'retain the current version'
    @jsondata:Name {value: "instance_configuration_version"}
    int:Signed32 instanceConfigurationVersion?;
    # An arbitrary JSON object overriding the default autoscaling policy. Don't set unless you really know what you are doing
    @jsondata:Name {value: "autoscaling_policy_override_json"}
    record {} autoscalingPolicyOverrideJson?;
    @jsondata:Name {value: "node_type"}
    ElasticsearchNodeType nodeType?;
    # The Elasticsearch cluster settings. When specified at the top level, provides a field-by-field default. When specified at the topology level, provides the override settings
    ElasticsearchConfiguration elasticsearch?;
    # Measured by the amount of a resource. The final cluster size is calculated using multipliers from the topology instance configuration
    TopologySize size?;
    # Set to true to enable autoscaling for this topology element, even if the cluster-level 'autoscaling_enabled' field is false. Note that 'autoscaling_tier_override' cannot be set to false if cluster-level 'autoscaling_enabled' is true. Currently only supported for the 'ml' tier
    @jsondata:Name {value: "autoscaling_tier_override"}
    boolean autoscalingTierOverride?;
    # The default number of zones in which data nodes will be placed
    @jsondata:Name {value: "zone_count"}
    int:Signed32 zoneCount?;
    @jsondata:Name {value: "autoscaling_min"}
    TopologySize autoscalingMin?;
    # Unique identifier of this topology element
    string id?;
    # The list of node roles for this topology element (ES version >= 7.10). Allowable values are: master, ingest, ml, data_hot, data_content, data_warm, data_cold, data_frozen, remote_cluster_client, transform
    @jsondata:Name {value: "node_roles"}
    ("master"|"ingest"|"ml"|"data_hot"|"data_content"|"data_warm"|"data_cold"|"data_frozen"|"remote_cluster_client"|"transform")[] nodeRoles?;
    @jsondata:Name {value: "topology_element_control"}
    TopologyElementControl topologyElementControl?;
};

# Represents the Queries record for the operation: search-eligible-remote-clusters
public type SearchEligibleRemoteClustersQueries record {
    # The version of the Elasticsearch cluster cluster that will potentially be configured to have remote clusters
    string version;
};

public type UpdateOrganizationRoleMappingRequest record {
    # The rules for mapping role assignments in the organization
    RoleMapping[] mappings;
};

# Represents the Queries record for the operation: get-traffic-filter-ruleset
public type GetTrafficFilterRulesetQueries record {
    # Retrieves a list of resources that are associated to the specified ruleset
    @http:Query {name: "include_associations"}
    boolean includeAssociations = false;
};

# Information about the Elasticsearch cluster snapshot retention
public type ClusterSnapshotRetention record {
    # Number of snapshots to retain
    int:Signed32 snapshots?;
    # Total retention period for all snapshots, with the format 'length unit' (space is optional), where unit can be one of: d (day), h (hour), min (minute)
    @jsondata:Name {value: "max_age"}
    string maxAge?;
};

public type GetRoleMappingsResponse record {
    # The list of role assignments for the organization
    RoleMapping[] mappings;
};

public type GetOrganizationClaimedDomainsResponse record {
    # The list of claimed domains in the organization
    string[] domains;
};

# For 2.x Elasticsearch clusters, specifies the information about the users and roles. For 5.x Elasticsearch clusters, use the Kibana management UI
public type ElasticsearchClusterSecurityInfo record {
    # An arbitrarily nested JSON object mapping roles to sets of resources and permissions - see the Elasticsearch security documentation for more details on roles
    record {} roles;
    @jsondata:Name {value: "users_roles"}
    ElasticsearchClusterRole[] usersRoles;
    # The resource version number of the security settings
    int:Signed32 version;
    # The most recent time the security settings were changed (ISO format in UTC)
    @jsondata:Name {value: "last_modified"}
    string lastModified;
    ElasticsearchClusterUser[] users;
};

# Assignment for a role with deployment scope
public type DeploymentRoleAssignment record {
    # When true, the role applies to all deployments in the organization, otherwise the role is scoped to the deployments specified in `deployment_ids`
    boolean all?;
    # The ID of the role that is assigned
    @jsondata:Name {value: "role_id"}
    string roleId;
    # The ID of the organization the role is scoped to
    @jsondata:Name {value: "organization_id"}
    string organizationId;
    # If provided, the user assigned this role assignment will be granted this application role when signing in to the deployment(s) specified in the role assignment
    @jsondata:Name {value: "application_roles"}
    string[] applicationRoles?;
    # The IDs of the deployments the role is scoped to. Must be absent if `all` is true, and present if `all` is false
    @jsondata:Name {value: "deployment_ids"}
    string[] deploymentIds?;
};

# The configuration options for the APM Server
public type ApmConfiguration record {
    # An arbitrary JSON object allowing (non-admin) cluster owners to set their parameters (only one of this and 'user_settings_yaml' is allowed), provided the parameters are on the allowlist and not on the denylist. (This field together with 'user_settings_override*' and 'system_settings' defines the total set of Apm settings)
    @jsondata:Name {value: "user_settings_json"}
    record {} userSettingsJson?;
    @jsondata:Name {value: "system_settings"}
    ApmSystemSettings systemSettings?;
    # An arbitrary YAML object allowing (non-admin) cluster owners to set their parameters (only one of this and 'user_settings_json' is allowed), provided the parameters are on the allowlist and not on the denylist. (These field together with 'user_settings_override*' and 'system_settings' defines the total set of Apm settings)
    @jsondata:Name {value: "user_settings_yaml"}
    string userSettingsYaml?;
    # An arbitrary JSON object allowing ECE admins owners to set clusters' parameters (only one of this and 'user_settings_override_yaml' is allowed), ie in addition to the documented 'system_settings'. (This field together with 'system_settings' and 'user_settings*' defines the total set of Apm settings)
    @jsondata:Name {value: "user_settings_override_json"}
    record {} userSettingsOverrideJson?;
    # The version of the Apm cluster (must be one of the ECE supported versions, and won't work unless it matches the APM version. Leave blank to auto-detect version.)
    string version?;
    # A docker URI that allows overriding of the default docker image specified for this version
    @jsondata:Name {value: "docker_image"}
    string dockerImage?;
    # An arbitrary YAML object allowing ECE admins owners to set clusters' parameters (only one of this and 'user_settings_override_json' is allowed), ie in addition to the documented 'system_settings'. (This field together with 'system_settings' and 'user_settings*' defines the total set of Apm settings)
    @jsondata:Name {value: "user_settings_override_yaml"}
    string userSettingsOverrideYaml?;
};

# Details about an orphaned Elasticsearch-dependent resources
public type ElasticsearchDependant record {
    # The kind of resource
    string kind;
    # The id of the orphaned resource
    string id;
};

# Holds diagnostics for an Elasticsearch cluster
public type Elasticsearch record {
    # A locally-unique user-specified id
    @jsondata:Name {value: "ref_id"}
    string refId;
    # The backend plan as JSON
    @jsondata:Name {value: "backend_plan"}
    record {} backendPlan;
    # The human readable name for the cluster (defaults to the generated cluster id if not specified)
    @jsondata:Name {value: "display_name"}
    string displayName;
};

public type VerificationCodeResponse record {
    # The verification code to use for the domain claim challenge
    string verification;
};

# Contains a list of deployments
public type DeploymentsListResponse record {
    # The deployments
    DeploymentsListingData[] deployments;
};

# The destination to send logs and metrics to
public type ObservabilityAbsoluteDeployment record {
    # RefId of the Elasticsearch cluster to send logs and/or metrics to. If not specified, refId is resolved automatically as long as the destination deployment contains a single Elasticsearch resource
    @jsondata:Name {value: "ref_id"}
    string refId?;
    # The deployment to send logs and/or metrics to. Contains either the deployment's ID or 'self'
    @jsondata:Name {value: "deployment_id"}
    string deploymentId;
};

# A query that doesn't match any documents
public type MatchNoneQuery record {
};

# The request that specifies the Elasticsearch or stateless (eg Kibana) instances to move to allocators as part of the upgrade plan. When used in conjunction with '\_\_all\_\_' (roll all instances as a single unit) strategy, these instances are not restarted, which can sometimes enable recovery plans when these instances are boot-looping
public type InstanceMoveRequest record {
    # The instance id that is going to be moved
    string 'from;
    # An optional list of allocator ids to which the instance should be moved. If not specified then any available allocator can be used (including the current one if it is healthy)
    string[] to?;
    # Tells the infrastructure that the instance should be considered as permanently down when deciding how to migrate data to new nodes. If left blank then the system will automatically decide (currently: will treat the instances as up)
    @jsondata:Name {value: "instance_down"}
    boolean instanceDown?;
};

# The authorization information for an Elasticsearch cluster user
public type ElasticsearchClusterRole record {
    # The list of roles for this user
    string[] roles;
    # The username
    string username;
};

# A request to create one or more invitations to an organization
public type OrganizationInvitationRequest record {
    # The email addresses to invite to the organization
    string[] emails;
    @jsondata:Name {value: "role_assignments"}
    RoleAssignments roleAssignments?;
    # The date and time when the invitation expires. Defaults to three days from now
    @jsondata:Name {value: "expires_in"}
    string expiresIn?;
};

# The trust relationship with external entities (remote environments, remote accounts...)
public type ExternalTrustRelationship record {
    # The ID of the external trust relationship
    @jsondata:Name {value: "trust_relationship_id"}
    string trustRelationshipId;
    # If true, all clusters in this external entity will be trusted and the `trust_allowlist` is ignored
    @jsondata:Name {value: "trust_all"}
    boolean trustAll;
    # The name of the external trust relationship. Retrieved from the TrustRelationship and ignored on write
    string name?;
    # The list of clusters to trust. Only used when `trust_all` is false
    @jsondata:Name {value: "trust_allowlist"}
    string[] trustAllowlist?;
};

# The plan control configuration options for the Integrations Server
public type IntegrationsServerPlanControlConfiguration record {
    # Set to 'forced' to force a reboot as part of the upgrade plan
    @jsondata:Name {value: "cluster_reboot"}
    "forced" clusterReboot?;
    # This timeout determines how long to give a cluster after it responds to API calls before performing actual operations on it. It defaults to 5s
    @jsondata:Name {value: "calm_wait_time"}
    int calmWaitTime?;
    # The total timeout in seconds after which the plan is cancelled even if it is not complete. Defaults to 4x the max memory capacity per node (in MB)
    int timeout?;
    # If true (default false), does not clear the maintenance flag (which prevents its API from being accessed except by the constructor) on new instances added until after a snapshot has been restored, otherwise, the maintenance flag is cleared once the new instances successfully join the new cluster
    @jsondata:Name {value: "extended_maintenance"}
    boolean extendedMaintenance?;
};

# Represents the Queries record for the operation: search-deployments
public type SearchDeploymentsQueries record {
    # Comma separated list of attributes to include in response for deployments found. Useful for reducing response size when retrieving many deployments. Use of this parameter moves the result to the minimal_metadata section of the response
    @http:Query {name: "minimal_metadata"}
    string minimalMetadata?;
};

# Represents the Queries record for the operation: get-costs-charts-by-deployment
public type GetCostsChartsByDeploymentQueries record {
    # The desired bucketing strategy for the charts. Defaults to `daily`
    @http:Query {name: "bucketing_strategy"}
    "daily"|"monthly" bucketingStrategy = "daily";
    # A datetime for the beginning of the desired range for which to fetch costs. Defaults to start of current month
    string 'from?;
    # A datetime for the end of the desired range for which to fetch costs. Defaults to the current date
    string to?;
};

# The plan control configuration options for the APM Server
public type ApmPlanControlConfiguration record {
    # Set to 'forced' to force a reboot as part of the upgrade plan
    @jsondata:Name {value: "cluster_reboot"}
    "forced" clusterReboot?;
    # This timeout determines how long to give a cluster after it responds to API calls before performing actual operations on it. It defaults to 5s
    @jsondata:Name {value: "calm_wait_time"}
    int calmWaitTime?;
    # The total timeout in seconds after which the plan is cancelled even if it is not complete. Defaults to 4x the max memory capacity per node (in MB)
    int timeout?;
    # If true (default false), does not clear the maintenance flag (which prevents its API from being accessed except by the constructor) on new instances added until after a snapshot has been restored, otherwise, the maintenance flag is cleared once the new instances successfully join the new cluster
    @jsondata:Name {value: "extended_maintenance"}
    boolean extendedMaintenance?;
};

# Defines the configuration parameters that control how the plan is applied. For example, the Elasticsearch cluster topology and APM Server settings
public type TransientApmPlanConfiguration record {
    @jsondata:Name {value: "plan_configuration"}
    ApmPlanControlConfiguration planConfiguration?;
    # The options for performing a plan change. Specify only one property each time. The default is `grow_and_shrink`
    PlanStrategy strategy?;
};

public type AppSearchPlanControlConfiguration record {
    # List of allocators on which instances are placed if possible (if not possible/not specified then any available allocator with space is used)
    @jsondata:Name {value: "preferred_allocators"}
    string[] preferredAllocators?;
    # Set to 'forced' to force a reboot as part of the upgrade plan
    @jsondata:Name {value: "cluster_reboot"}
    "forced" clusterReboot?;
    @jsondata:Name {value: "move_allocators"}
    AllocatorMoveRequest[] moveAllocators?;
    # This timeout determines how long to give a cluster after it responds to API calls before performing actual operations on it. It defaults to 5s
    @jsondata:Name {value: "calm_wait_time"}
    int calmWaitTime?;
    @jsondata:Name {value: "move_instances"}
    InstanceMoveRequest[] moveInstances?;
    # If true (default: false) does not allow re-using any existing instances currently in the cluster, ie even unchanged instances will be re-created
    @jsondata:Name {value: "reallocate_instances"}
    boolean reallocateInstances?;
    # The total timeout in seconds after which the plan is cancelled even if it is not complete. Defaults to 4x the max memory capacity per node (in MB)
    int timeout?;
    # If true (default false), does not clear the maintenance flag (which prevents its API from being accessed except by the constructor) on new instances added until after a snapshot has been restored, otherwise, the maintenance flag is cleared once the new instances successfully join the new cluster
    @jsondata:Name {value: "extended_maintenance"}
    boolean extendedMaintenance?;
};

# Shards status represented as green, yellow, or red, as returned by the Elasticsearch cluster health API
public type ElasticsearchShardsStatus record {
    # Indicates the elasticsearch cluster health status as a color
    "green"|"red"|"yellow" status;
};

# Defines the topology of the APM Server nodes. For example, the number or capacity of the nodes, and where you can allocate the nodes
public type ApmTopologyElement record {
    # Controls the allocation of this topology element as well as allowed sizes and node_types. It needs to match the id of an existing instance configuration
    @jsondata:Name {value: "instance_configuration_id"}
    string instanceConfigurationId?;
    # The version of the Instance Configuration Id. If it is unset, the meaning depends on read vs writes. For deployment reads, it is equivalent to version 0 (or the IC is unversioned); for deployment creates and deployment template use, it is equivalent to 'the latest version'; and for deployment updates, it is equivalent to 'retain the current version'
    @jsondata:Name {value: "instance_configuration_version"}
    int:Signed32 instanceConfigurationVersion?;
    # Measured by the amount of a resource. The final cluster size is calculated using multipliers from the topology instance configuration
    TopologySize size?;
    # number of zones in which nodes will be placed
    @jsondata:Name {value: "zone_count"}
    int:Signed32 zoneCount?;
    # The configuration options for the APM Server
    ApmConfiguration apm?;
};

# Represents the Queries record for the operation: get-costs-items
public type GetCostsItemsQueries record {
    # A datetime for the beginning of the desired range for which to fetch costs. Defaults to start of current month
    string 'from?;
    # A datetime for the end of the desired range for which to fetch costs. Defaults to the current date
    string to?;
};

# Additional information about the new deployment object
public type DeploymentCreateMetadata record {
    # Arbitrary user-defined metadata associated with this deployment
    MetadataItem[] tags?;
};

# The query that matches documents with fields that contain terms with a specified, not analyzed, prefix
public type PrefixQuery record {
    # An optional boost value to apply to the query
    float boost?;
    # The prefix to search for
    string value;
};

# Represents the Queries record for the operation: reset-elasticsearch-user-password
public type ResetElasticsearchUserPasswordQueries record {
    # If true, will not reset elastic user password and instead will return a status code signaling whether or not the current credentials are ready to use (eg from creation or the last call to _reset_password)
    @http:Query {name: "check_completion"}
    boolean checkCompletion = false;
};

# Node types to enable for an AppSearch instance
public type AppSearchNodeTypes record {
    # Defines whether this instance should run as Application/API server
    boolean appserver;
    # Defines whether this instance should run as background worker
    boolean 'worker;
};

# The configuration settings for the traffic filter
public type RulesetAssociations record {
    # List of associations
    FilterAssociation[] associations;
    # Total number of associations. This includes associations the user does not have permission to view
    @jsondata:Name {value: "total_associations"}
    int:Signed32 totalAssociations;
};

# The plan for the APM Server
public type ApmPlan record {
    # Defines the configuration parameters that control how the plan is applied. For example, the Elasticsearch cluster topology and APM Server settings
    TransientApmPlanConfiguration transient?;
    @jsondata:Name {value: "cluster_topology"}
    ApmTopologyElement[] clusterTopology?;
    # The configuration options for the APM Server
    ApmConfiguration apm;
};

public type AppSearchConfiguration record {
    # An arbitrary JSON object allowing (non-admin) cluster owners to set their parameters (only one of this and 'user_settings_yaml' is allowed), provided the parameters are on the allowlist and not on the denylist. (This field together with 'user_settings_override*' and 'system_settings' defines the total set of AppSearch settings)
    @jsondata:Name {value: "user_settings_json"}
    record {} userSettingsJson?;
    @jsondata:Name {value: "system_settings"}
    AppSearchSystemSettings systemSettings?;
    # An arbitrary YAML object allowing (non-admin) cluster owners to set their parameters (only one of this and 'user_settings_json' is allowed), provided the parameters are on the allowlist and not on the denylist. (These field together with 'user_settings_override*' and 'system_settings' defines the total set of AppSearch settings)
    @jsondata:Name {value: "user_settings_yaml"}
    string userSettingsYaml?;
    # An arbitrary JSON object allowing ECE admins owners to set clusters' parameters (only one of this and 'user_settings_override_yaml' is allowed), ie in addition to the documented 'system_settings'. (This field together with 'system_settings' and 'user_settings*' defines the total set of AppSearch settings)
    @jsondata:Name {value: "user_settings_override_json"}
    record {} userSettingsOverrideJson?;
    # The version of the AppSearch cluster (must be one of the ECE supported versions, and won't work unless it matches the Elasticsearch version. Leave blank to auto-detect version.)
    string version?;
    # A docker URI that allows overriding of the default docker image specified for this version
    @jsondata:Name {value: "docker_image"}
    string dockerImage?;
    # An arbitrary YAML object allowing ECE admins owners to set clusters' parameters (only one of this and 'user_settings_override_json' is allowed), ie in addition to the documented 'system_settings'. (This field together with 'system_settings' and 'user_settings*' defines the total set of AppSearch settings)
    @jsondata:Name {value: "user_settings_override_yaml"}
    string userSettingsOverrideYaml?;
};

# Holds diagnostics for an APM resource
public type Apm record {
    # A locally-unique user-specified id
    @jsondata:Name {value: "ref_id"}
    string refId;
    # The user-specified id of the Elasticsearch Cluster that this will link to
    @jsondata:Name {value: "elasticsearch_cluster_ref_id"}
    string elasticsearchClusterRefId;
    # The backend plan as JSON
    @jsondata:Name {value: "backend_plan"}
    record {} backendPlan;
    # The human readable name (defaults to the generated cluster id if not specified)
    @jsondata:Name {value: "display_name"}
    string displayName;
};
