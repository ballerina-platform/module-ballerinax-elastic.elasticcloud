// AUTO-GENERATED FILE. DO NOT MODIFY.
// This file is auto-generated by the Ballerina OpenAPI tool.

import ballerina/data.jsondata;
import ballerina/http;
import ballerina/mime;

# This RESTful API enables you to perform most of the operations available in the UI console through API calls.
# 
# You can [create an API key](https://www.elastic.co/guide/en/cloud/current/ec-api-authentication.html) to quickly and easily authenticate, then use the API to create and manage deployments, configure remote clusters, set up traffic filters, manage extensions, and much more.
# Access the API from its base URL at `api.elastic-cloud.com`.
# 
# To manage your serverless projects, use the [Elastic Cloud Serverless API](https://www.elastic.co/docs/api/doc/elastic-cloud-serverless).
# 
# ## Documentation source and versions
# 
# This documentation is derived from https://api.elastic-cloud.com/api/v1/api-docs-user/swagger.json.
# It is provided under license [Attribution-NonCommercial-NoDerivatives 4.0 International](https://creativecommons.org/licenses/by-nc-nd/4.0/).
public isolated client class Client {
    final http:Client clientEp;
    final readonly & ApiKeysConfig apiKeyConfig;
    # Gets invoked to initialize the `connector`.
    #
    # + apiKeyConfig - API keys for authorization 
    # + config - The configurations to be used when initializing the `connector` 
    # + serviceUrl - URL of the target service 
    # + return - An error if connector initialization failed 
    public isolated function init(ApiKeysConfig apiKeyConfig, ConnectionConfig config =  {}, string serviceUrl = "https://api.elastic-cloud.com/api/v1") returns error? {
        http:ClientConfiguration httpClientConfig = {httpVersion: config.httpVersion, http1Settings: config.http1Settings, http2Settings: config.http2Settings, timeout: config.timeout, forwarded: config.forwarded, followRedirects: config.followRedirects, poolConfig: config.poolConfig, cache: config.cache, compression: config.compression, circuitBreaker: config.circuitBreaker, retryConfig: config.retryConfig, cookieConfig: config.cookieConfig, responseLimits: config.responseLimits, secureSocket: config.secureSocket, proxy: config.proxy, socketConfig: config.socketConfig, validation: config.validation, laxDataBinding: config.laxDataBinding};
        self.clientEp = check new (serviceUrl, httpClientConfig);
        self.apiKeyConfig = apiKeyConfig.cloneReadOnly();
    }

    # Fetch current account information
    #
    # + headers - Headers to be sent with the request 
    # + return - Account fetched successfully 
    resource isolated function get account(map<string|string[]> headers = {}) returns AccountResponse|error {
        string resourcePath = string `/account`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Updates the current account
    #
    # + headers - Headers to be sent with the request 
    # + payload - the current account 
    # + return - Account updated successfully 
    resource isolated function put account(AccountUpdateRequest payload, map<string|string[]> headers = {}) returns AccountResponse|error {
        string resourcePath = string `/account`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Updates the current account
    #
    # + headers - Headers to be sent with the request 
    # + payload - All changes in the specified object are applied to the current account according to the JSON Merge Patch processing rules. Omitting existing fields causes the same values to be reapplied. Specifying a `null` value reverts the field to the default value, or removes the field when no default value exists 
    # + return - Account updated successfully 
    resource isolated function patch account(string payload, map<string|string[]> headers = {}) returns AccountResponse|error {
        string resourcePath = string `/account`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->patch(resourcePath, request, headers);
    }

    # Get costs overview for the organization. Currently unavailable in self-hosted ECE.
    #
    # + organizationId - Identifier for the organization
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Top-level cost overview for the organization 
    # 
    # # Deprecated
    @deprecated
    resource isolated function get billing/costs/[string organizationId](map<string|string[]> headers = {}, *GetCostsOverviewQueries queries) returns CostsOverview|error {
        string resourcePath = string `/billing/costs/${getEncodedUri(organizationId)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get charts for the organization. Currently unavailable in self-hosted ECE.
    #
    # + organizationId - Identifier for the organization
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - The usage charts of an organization 
    # 
    # # Deprecated
    @deprecated
    resource isolated function get billing/costs/[string organizationId]/charts(map<string|string[]> headers = {}, *GetCostsChartsQueries queries) returns ChartItems|error {
        string resourcePath = string `/billing/costs/${getEncodedUri(organizationId)}/charts`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get deployments costs for the organization. Currently unavailable in self-hosted ECE.
    #
    # + organizationId - Identifier for the organization
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - The costs associated to a set of products 
    # 
    # # Deprecated
    @deprecated
    resource isolated function get billing/costs/[string organizationId]/deployments(GetCostsDeploymentsHeaders headers = {}, *GetCostsDeploymentsQueries queries) returns DeploymentsCosts|error {
        string resourcePath = string `/billing/costs/${getEncodedUri(organizationId)}/deployments`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Get charts by deployment. Currently unavailable in self-hosted ECE.
    #
    # + organizationId - Identifier for the organization
    # + deploymentId - Id of a Deployment
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - The usage charts of a deployment 
    # 
    # # Deprecated
    @deprecated
    resource isolated function get billing/costs/[string organizationId]/deployments/[string deploymentId]/charts(map<string|string[]> headers = {}, *GetCostsChartsByDeploymentQueries queries) returns ChartItems|error {
        string resourcePath = string `/billing/costs/${getEncodedUri(organizationId)}/deployments/${getEncodedUri(deploymentId)}/charts`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get itemized costs by deployments. Currently unavailable in self-hosted ECE.
    #
    # + organizationId - Identifier for the organization
    # + deploymentId - Id of a Deployment
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - The costs associated to a set items billed for a single deployment 
    # 
    # # Deprecated
    @deprecated
    resource isolated function get billing/costs/[string organizationId]/deployments/[string deploymentId]/items(GetCostsItemsByDeploymentHeaders headers = {}, *GetCostsItemsByDeploymentQueries queries) returns ItemsCosts|error {
        string resourcePath = string `/billing/costs/${getEncodedUri(organizationId)}/deployments/${getEncodedUri(deploymentId)}/items`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Get itemized costs for the organization. Currently unavailable in self-hosted ECE.
    #
    # + organizationId - Identifier for the organization
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - The costs associated to a set of items 
    # 
    # # Deprecated
    @deprecated
    resource isolated function get billing/costs/[string organizationId]/items(map<string|string[]> headers = {}, *GetCostsItemsQueries queries) returns ItemsCosts|error {
        string resourcePath = string `/billing/costs/${getEncodedUri(organizationId)}/items`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # List Deployments
    #
    # + headers - Headers to be sent with the request 
    # + return - The list of deployments that belong to the authenticated user 
    resource isolated function get deployments(map<string|string[]> headers = {}) returns DeploymentsListResponse|error {
        string resourcePath = string `/deployments`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Create Deployment
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The deployment definition 
    # + return - The request was valid (used when validate_only is true) 
    resource isolated function post deployments(DeploymentCreateRequest payload, map<string|string[]> headers = {}, *CreateDeploymentQueries queries) returns DeploymentCreateResponse|error {
        string resourcePath = string `/deployments`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Search Deployments
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - (Optional) The search query to run. When not specified, all of the deployments are matched 
    # + return - The list of deployments that match the specified query and belong to the authenticated user 
    resource isolated function post deployments/_search(SearchRequest payload, map<string|string[]> headers = {}, *SearchDeploymentsQueries queries) returns DeploymentsSearchResponse|error {
        string resourcePath = string `/deployments/_search`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get eligible remote clusters
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - (Optional) The search query to run against all deployments containing eligible remote clusters. When not specified, all the eligible deployments are matched 
    # + return - List of deployments which contains eligible remote clusters for a specific version 
    resource isolated function post deployments/eligible\-remote\-clusters(SearchRequest payload, map<string|string[]> headers = {}, *SearchEligibleRemoteClustersQueries queries) returns DeploymentsSearchResponse|error {
        string resourcePath = string `/deployments/eligible-remote-clusters`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # List Extensions
    #
    # + headers - Headers to be sent with the request 
    # + return - The extensions that are available 
    resource isolated function get deployments/extensions(map<string|string[]> headers = {}) returns Extensions|error {
        string resourcePath = string `/deployments/extensions`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Create an extension
    #
    # + headers - Headers to be sent with the request 
    # + payload - the data that creates the extension 
    # + return - The extension that was just created 
    resource isolated function post deployments/extensions(CreateExtensionRequest payload, map<string|string[]> headers = {}) returns Extension|error {
        string resourcePath = string `/deployments/extensions`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get Extension
    #
    # + extensionId - Id of an extension
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - The Extension 
    resource isolated function get deployments/extensions/[string extensionId](map<string|string[]> headers = {}, *GetExtensionQueries queries) returns Extension|error {
        string resourcePath = string `/deployments/extensions/${getEncodedUri(extensionId)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Uploads the Extension
    #
    # + extensionId - Id of an extension
    # + headers - Headers to be sent with the request 
    # + return - Archive uploaded successfully 
    resource isolated function put deployments/extensions/[string extensionId](ExtensionsextensionIdBody payload, map<string|string[]> headers = {}) returns Extension|error {
        string resourcePath = string `/deployments/extensions/${getEncodedUri(extensionId)}`;
        http:Request request = new;
        mime:Entity[] bodyParts = check createBodyParts(check jsondata:toJson(payload).ensureType());
        request.setBodyParts(bodyParts);
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Update Extension
    #
    # + extensionId - Id of an extension
    # + headers - Headers to be sent with the request 
    # + payload - The extension update data 
    # + return - Extension updated successfully 
    resource isolated function post deployments/extensions/[string extensionId](UpdateExtensionRequest payload, map<string|string[]> headers = {}) returns Extension|error {
        string resourcePath = string `/deployments/extensions/${getEncodedUri(extensionId)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Delete Extension
    #
    # + extensionId - Id of an extension
    # + headers - Headers to be sent with the request 
    # + return - Extension deleted successfully 
    resource isolated function delete deployments/extensions/[string extensionId](map<string|string[]> headers = {}) returns EmptyResponse|error {
        string resourcePath = string `/deployments/extensions/${getEncodedUri(extensionId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get deployment templates
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - The deployment templates were returned successfully 
    resource isolated function get deployments/templates(map<string|string[]> headers = {}, *GetDeploymentTemplatesV2Queries queries) returns DeploymentTemplateInfoV2[]|error {
        string resourcePath = string `/deployments/templates`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get deployment template
    #
    # + templateId - The identifier for the deployment template
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - The deployment template was found and returned successfully 
    resource isolated function get deployments/templates/[string templateId](map<string|string[]> headers = {}, *GetDeploymentTemplateV2Queries queries) returns DeploymentTemplateInfoV2|error {
        string resourcePath = string `/deployments/templates/${getEncodedUri(templateId)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get associated rulesets
    #
    # + associationType - Association type
    # + associatedEntityId - Associated entity ID
    # + headers - Headers to be sent with the request 
    # + return - Rulesets in the deployment were successfully returned 
    resource isolated function get deployments/traffic\-filter/associations/[string associationType]/[string associatedEntityId]/rulesets(map<string|string[]> headers = {}) returns TrafficFilterSettings|error {
        string resourcePath = string `/deployments/traffic-filter/associations/${getEncodedUri(associationType)}/${getEncodedUri(associatedEntityId)}/rulesets`;
        return self.clientEp->get(resourcePath, headers);
    }

    # List traffic filter claimed link id
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - The collection of traffic filter claimed link id 
    resource isolated function get deployments/traffic\-filter/link\-ids(map<string|string[]> headers = {}, *GetTrafficFilterClaimedLinkIdsQueries queries) returns TrafficFilterClaimedLinkIds|error {
        string resourcePath = string `/deployments/traffic-filter/link-ids`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Claim a link id
    #
    # + headers - Headers to be sent with the request 
    # + payload - The specification for traffic filter claimed link id 
    # + return - The ruleset definition is valid and the creation has started 
    resource isolated function post deployments/traffic\-filter/link\-ids/_claim(TrafficFilterClaimedLinkIdRequest payload, map<string|string[]> headers = {}) returns TrafficFilterClaimedLinkIdInfo|error {
        string resourcePath = string `/deployments/traffic-filter/link-ids/_claim`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Unclaims a link id
    #
    # + headers - Headers to be sent with the request 
    # + payload - The specification for traffic filter claimed link id 
    # + return - The claimed link id was successfully deleted 
    resource isolated function post deployments/traffic\-filter/link\-ids/_unclaim(TrafficFilterClaimedLinkIdRequest payload, map<string|string[]> headers = {}) returns EmptyResponse|error {
        string resourcePath = string `/deployments/traffic-filter/link-ids/_unclaim`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # List traffic filter rulesets
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - The collection of traffic filter routes 
    resource isolated function get deployments/traffic\-filter/rulesets(map<string|string[]> headers = {}, *GetTrafficFilterRulesetsQueries queries) returns TrafficFilterRulesets|error {
        string resourcePath = string `/deployments/traffic-filter/rulesets`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Create a ruleset
    #
    # + headers - Headers to be sent with the request 
    # + payload - The specification for traffic filter ruleset 
    # + return - The ruleset definition is valid and the creation has started 
    resource isolated function post deployments/traffic\-filter/rulesets(TrafficFilterRulesetRequest payload, map<string|string[]> headers = {}) returns TrafficFilterRulesetResponse|error {
        string resourcePath = string `/deployments/traffic-filter/rulesets`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Retrieves the ruleset by ID.
    #
    # + rulesetId - The mandatory ruleset ID
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - The container for a set of traffic filter rules 
    resource isolated function get deployments/traffic\-filter/rulesets/[string rulesetId](map<string|string[]> headers = {}, *GetTrafficFilterRulesetQueries queries) returns TrafficFilterRulesetInfo|error {
        string resourcePath = string `/deployments/traffic-filter/rulesets/${getEncodedUri(rulesetId)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Updates a ruleset
    #
    # + rulesetId - The mandatory ruleset ID
    # + headers - Headers to be sent with the request 
    # + payload - The specification for traffic filter ruleset 
    # + return - The ruleset definition was valid and the update has started 
    resource isolated function put deployments/traffic\-filter/rulesets/[string rulesetId](TrafficFilterRulesetRequest payload, map<string|string[]> headers = {}) returns TrafficFilterRulesetResponse|error {
        string resourcePath = string `/deployments/traffic-filter/rulesets/${getEncodedUri(rulesetId)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete a ruleset
    #
    # + rulesetId - The mandatory ruleset ID
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - The traffic filter ruleset was successfully deleted 
    resource isolated function delete deployments/traffic\-filter/rulesets/[string rulesetId](map<string|string[]> headers = {}, *DeleteTrafficFilterRulesetQueries queries) returns EmptyResponse|error {
        string resourcePath = string `/deployments/traffic-filter/rulesets/${getEncodedUri(rulesetId)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get associated deployments
    #
    # + rulesetId - The mandatory ruleset ID
    # + headers - Headers to be sent with the request 
    # + return - Associations referred by traffic filter rulesets were successfully returned 
    resource isolated function get deployments/traffic\-filter/rulesets/[string rulesetId]/associations(map<string|string[]> headers = {}) returns RulesetAssociations|error {
        string resourcePath = string `/deployments/traffic-filter/rulesets/${getEncodedUri(rulesetId)}/associations`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Create ruleset association
    #
    # + rulesetId - The mandatory ruleset ID
    # + headers - Headers to be sent with the request 
    # + payload - Mandatory ruleset association description 
    # + return - Create association request was valid and the association already exists 
    resource isolated function post deployments/traffic\-filter/rulesets/[string rulesetId]/associations(FilterAssociation payload, map<string|string[]> headers = {}) returns EmptyResponse|error {
        string resourcePath = string `/deployments/traffic-filter/rulesets/${getEncodedUri(rulesetId)}/associations`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Delete ruleset association
    #
    # + rulesetId - The mandatory ruleset ID
    # + associationType - Association type
    # + associatedEntityId - Associated entity ID
    # + headers - Headers to be sent with the request 
    # + return - Delete association request was valid and the association has been deleted 
    resource isolated function delete deployments/traffic\-filter/rulesets/[string rulesetId]/associations/[string associationType]/[string associatedEntityId](map<string|string[]> headers = {}) returns EmptyResponse|error {
        string resourcePath = string `/deployments/traffic-filter/rulesets/${getEncodedUri(rulesetId)}/associations/${getEncodedUri(associationType)}/${getEncodedUri(associatedEntityId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get Deployment
    #
    # + deploymentId - Identifier for the Deployment
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - The Deployment info response 
    resource isolated function get deployments/[string deploymentId](map<string|string[]> headers = {}, *GetDeploymentQueries queries) returns DeploymentGetResponse|error {
        string resourcePath = string `/deployments/${getEncodedUri(deploymentId)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Update Deployment
    #
    # + deploymentId - Identifier for the Deployment
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The deployment definition 
    # + return - The request was valid and the deployment was updated 
    resource isolated function put deployments/[string deploymentId](DeploymentUpdateRequest payload, map<string|string[]> headers = {}, *UpdateDeploymentQueries queries) returns DeploymentUpdateResponse|error {
        string resourcePath = string `/deployments/${getEncodedUri(deploymentId)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Restores a shutdown Deployment
    #
    # + deploymentId - Identifier for the Deployment
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - The request was valid and the resources of the deployment were restored 
    resource isolated function post deployments/[string deploymentId]/_restore(map<string|string[]> headers = {}, *RestoreDeploymentQueries queries) returns DeploymentRestoreResponse|error {
        string resourcePath = string `/deployments/${getEncodedUri(deploymentId)}/_restore`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Shuts down Deployment
    #
    # + deploymentId - Identifier for the Deployment
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - The request was valid and the resources of the deployment were shutdown 
    resource isolated function post deployments/[string deploymentId]/_shutdown(map<string|string[]> headers = {}, *ShutdownDeploymentQueries queries) returns DeploymentShutdownResponse|error {
        string resourcePath = string `/deployments/${getEncodedUri(deploymentId)}/_shutdown`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get Deployment APM Resource Info
    #
    # + deploymentId - Identifier for the Deployment
    # + refId - User-specified RefId for the Resource (or '_main' if there is only one)
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Standard response 
    resource isolated function get deployments/[string deploymentId]/apm/[string refId](map<string|string[]> headers = {}, *GetDeploymentApmResourceInfoQueries queries) returns ApmResourceInfo|error {
        string resourcePath = string `/deployments/${getEncodedUri(deploymentId)}/apm/${getEncodedUri(refId)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Reset the secret token for an APM resource.
    #
    # + deploymentId - Identifier for the Deployment
    # + refId - User-specified RefId for the Resource (or '_main' if there is only one)
    # + headers - Headers to be sent with the request 
    # + return - Response containing the new secret token, plan to apply it starts 
    resource isolated function post deployments/[string deploymentId]/apm/[string refId]/_reset\-token(map<string|string[]> headers = {}) returns ApmCrudResponse|error {
        string resourcePath = string `/deployments/${getEncodedUri(deploymentId)}/apm/${getEncodedUri(refId)}/_reset-token`;
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get Deployment App Search Resource Info
    #
    # + deploymentId - Identifier for the Deployment
    # + refId - User-specified RefId for the Resource (or '_main' if there is only one)
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Standard response 
    resource isolated function get deployments/[string deploymentId]/appsearch/[string refId](map<string|string[]> headers = {}, *GetDeploymentAppsearchResourceInfoQueries queries) returns AppSearchResourceInfo|error {
        string resourcePath = string `/deployments/${getEncodedUri(deploymentId)}/appsearch/${getEncodedUri(refId)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Set AppSearch read-only status
    #
    # + deploymentId - Identifier for the Deployment
    # + refId - User-specified RefId for the Resource (or '_main' if there is only one)
    # + headers - Headers to be sent with the request 
    # + return - Standard response 
    resource isolated function get deployments/[string deploymentId]/appsearch/[string refId]/read_only_mode(map<string|string[]> headers = {}) returns ReadOnlyResponse|error {
        string resourcePath = string `/deployments/${getEncodedUri(deploymentId)}/appsearch/${getEncodedUri(refId)}/read_only_mode`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Set AppSearch read-only status
    #
    # + deploymentId - Identifier for the Deployment
    # + refId - User-specified RefId for the Resource (or '_main' if there is only one)
    # + headers - Headers to be sent with the request 
    # + payload - read-only request body 
    # + return - Standard response 
    resource isolated function put deployments/[string deploymentId]/appsearch/[string refId]/read_only_mode(ReadOnlyRequest payload, map<string|string[]> headers = {}) returns ReadOnlyResponse|error {
        string resourcePath = string `/deployments/${getEncodedUri(deploymentId)}/appsearch/${getEncodedUri(refId)}/read_only_mode`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Get certificate authority
    #
    # + deploymentId - Identifier for the Deployment
    # + headers - Headers to be sent with the request 
    # + return - The certificate authority used to sign the certificates of this deployment 
    resource isolated function get deployments/[string deploymentId]/certificate\-authority(map<string|string[]> headers = {}) returns CertificateAuthority|error {
        string resourcePath = string `/deployments/${getEncodedUri(deploymentId)}/certificate-authority`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Get Deployment Elasticsearch Resource Info
    #
    # + deploymentId - Identifier for the Deployment
    # + refId - User-specified RefId for the Resource (or '_main' if there is only one)
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Standard response 
    resource isolated function get deployments/[string deploymentId]/elasticsearch/[string refId](map<string|string[]> headers = {}, *GetDeploymentEsResourceInfoQueries queries) returns ElasticsearchResourceInfo|error {
        string resourcePath = string `/deployments/${getEncodedUri(deploymentId)}/elasticsearch/${getEncodedUri(refId)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Migrate Elasticsearch and associated Kibana resources to enable CCR
    #
    # + deploymentId - Identifier for the Deployment
    # + refId - User-specified RefId for the Resource (or '_main' if there is only one)
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Standard response 
    resource isolated function post deployments/[string deploymentId]/elasticsearch/[string refId]/_enable\-ccr(map<string|string[]> headers = {}, *EnableDeploymentResourceCcrQueries queries) returns DeploymentResourceCommandResponse|error {
        string resourcePath = string `/deployments/${getEncodedUri(deploymentId)}/elasticsearch/${getEncodedUri(refId)}/_enable-ccr`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Migrate Elasticsearch resource to use ILM
    #
    # + deploymentId - Identifier for the Deployment
    # + refId - User-specified RefId for the Resource (or '_main' if there is only one)
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - Information to build the ILM policies that will be created 
    # + return - Standard response 
    resource isolated function post deployments/[string deploymentId]/elasticsearch/[string refId]/_enable\-ilm(EnableIlmRequest payload, map<string|string[]> headers = {}, *EnableDeploymentResourceIlmQueries queries) returns DeploymentResourceCommandResponse|error {
        string resourcePath = string `/deployments/${getEncodedUri(deploymentId)}/elasticsearch/${getEncodedUri(refId)}/_enable-ilm`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Migrate Elasticsearch resource to use SLM
    #
    # + deploymentId - Identifier for the Deployment
    # + refId - User-specified RefId for the Resource (or '_main' if there is only one)
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Standard response 
    resource isolated function post deployments/[string deploymentId]/elasticsearch/[string refId]/_enable\-slm(map<string|string[]> headers = {}, *EnableDeploymentResourceSlmQueries queries) returns DeploymentResourceCommandResponse|error {
        string resourcePath = string `/deployments/${getEncodedUri(deploymentId)}/elasticsearch/${getEncodedUri(refId)}/_enable-slm`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Reset 'elastic' user password
    #
    # + deploymentId - Identifier for the Deployment
    # + refId - User-specified RefId for the Resource (or '_main' if there is only one)
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - The password reset was out carried successfully 
    resource isolated function post deployments/[string deploymentId]/elasticsearch/[string refId]/_reset\-password(map<string|string[]> headers = {}, *ResetElasticsearchUserPasswordQueries queries) returns ElasticsearchElasticUserPasswordResetResponse|error {
        string resourcePath = string `/deployments/${getEncodedUri(deploymentId)}/elasticsearch/${getEncodedUri(refId)}/_reset-password`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Restart Deployment Elasticsearch Resource
    #
    # + deploymentId - Identifier for the Deployment
    # + refId - User-specified RefId for the Resource (or '_main' if there is only one)
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - The restart command was issued successfully 
    resource isolated function post deployments/[string deploymentId]/elasticsearch/[string refId]/_restart(map<string|string[]> headers = {}, *RestartDeploymentEsResourceQueries queries) returns DeploymentResourceCommandResponse|error {
        string resourcePath = string `/deployments/${getEncodedUri(deploymentId)}/elasticsearch/${getEncodedUri(refId)}/_restart`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Shutdown Deployment Elasticsearch Resource
    #
    # + deploymentId - Identifier for the Deployment
    # + refId - User-specified RefId for the Resource (or '_main' if there is only one)
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Standard response 
    resource isolated function post deployments/[string deploymentId]/elasticsearch/[string refId]/_shutdown(map<string|string[]> headers = {}, *ShutdownDeploymentEsResourceQueries queries) returns DeploymentResourceCommandResponse|error {
        string resourcePath = string `/deployments/${getEncodedUri(deploymentId)}/elasticsearch/${getEncodedUri(refId)}/_shutdown`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get eligible remote clusters
    #
    # + deploymentId - Identifier for the Deployment
    # + refId - User-specified RefId for the Resource (or '_main' if there is only one)
    # + headers - Headers to be sent with the request 
    # + payload - (Optional) The search query to run against all deployments containing eligible remote clusters. When not specified, all the eligible deployments are matched 
    # + return - List of deployments which contains eligible remote clusters for the resource 
    resource isolated function post deployments/[string deploymentId]/elasticsearch/[string refId]/eligible\-remote\-clusters(SearchRequest payload, map<string|string[]> headers = {}) returns DeploymentsSearchResponse|error {
        string resourcePath = string `/deployments/${getEncodedUri(deploymentId)}/elasticsearch/${getEncodedUri(refId)}/eligible-remote-clusters`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get the items in the Elasticsearch resource keystore
    #
    # + deploymentId - Identifier for the Deployment
    # + refId - User-specified RefId for the Resource (or '_main' if there is only one)
    # + headers - Headers to be sent with the request 
    # + return - The contents of the Elasticsearch keystore, with values redacted 
    resource isolated function get deployments/[string deploymentId]/elasticsearch/[string refId]/keystore(map<string|string[]> headers = {}) returns KeystoreContents|error {
        string resourcePath = string `/deployments/${getEncodedUri(deploymentId)}/elasticsearch/${getEncodedUri(refId)}/keystore`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Add or remove items from the Elasticsearch resource keystore
    #
    # + deploymentId - Identifier for the Deployment
    # + refId - User-specified RefId for the Resource (or '_main' if there is only one)
    # + headers - Headers to be sent with the request 
    # + payload - The new settings that will be applied to the keystore of the Elasticsearch resource 
    # + return - The new contents of the Elasticsearch keystore 
    resource isolated function patch deployments/[string deploymentId]/elasticsearch/[string refId]/keystore(KeystoreContents payload, map<string|string[]> headers = {}) returns KeystoreContents|error {
        string resourcePath = string `/deployments/${getEncodedUri(deploymentId)}/elasticsearch/${getEncodedUri(refId)}/keystore`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->patch(resourcePath, request, headers);
    }

    # Get certificate based remote clusters
    #
    # + deploymentId - Identifier for the Deployment
    # + refId - User-specified RefId for the Resource (or '_main' if there is only one)
    # + headers - Headers to be sent with the request 
    # + return - List of certificate based remote clusters for the resource 
    resource isolated function get deployments/[string deploymentId]/elasticsearch/[string refId]/remote\-clusters(map<string|string[]> headers = {}) returns RemoteResources|error {
        string resourcePath = string `/deployments/${getEncodedUri(deploymentId)}/elasticsearch/${getEncodedUri(refId)}/remote-clusters`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Set certificate based remote clusters
    #
    # + deploymentId - Identifier for the Deployment
    # + refId - User-specified RefId for the Resource (or '_main' if there is only one)
    # + headers - Headers to be sent with the request 
    # + payload - List of certificate based remote clusters for the resource 
    # + return - The Remote Clusters were updated 
    resource isolated function put deployments/[string deploymentId]/elasticsearch/[string refId]/remote\-clusters(RemoteResources payload, map<string|string[]> headers = {}) returns EmptyResponse|error {
        string resourcePath = string `/deployments/${getEncodedUri(deploymentId)}/elasticsearch/${getEncodedUri(refId)}/remote-clusters`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Get Deployment Enterprise Search Resource Info
    #
    # + deploymentId - Identifier for the Deployment
    # + refId - User-specified RefId for the Resource (or '_main' if there is only one)
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Standard response 
    resource isolated function get deployments/[string deploymentId]/enterprise_search/[string refId](map<string|string[]> headers = {}, *GetDeploymentEnterpriseSearchResourceInfoQueries queries) returns EnterpriseSearchResourceInfo|error {
        string resourcePath = string `/deployments/${getEncodedUri(deploymentId)}/enterprise_search/${getEncodedUri(refId)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get Deployment Integrations Server Resource Info
    #
    # + deploymentId - Identifier for the Deployment
    # + refId - User-specified RefId for the Resource (or '_main' if there is only one)
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Standard response 
    resource isolated function get deployments/[string deploymentId]/integrations_server/[string refId](map<string|string[]> headers = {}, *GetDeploymentIntegrationsServerResourceInfoQueries queries) returns IntegrationsServerResourceInfo|error {
        string resourcePath = string `/deployments/${getEncodedUri(deploymentId)}/integrations_server/${getEncodedUri(refId)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get Deployment Kibana Resource Info
    #
    # + deploymentId - Identifier for the Deployment
    # + refId - User-specified RefId for the Resource (or '_main' if there is only one)
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Standard response 
    resource isolated function get deployments/[string deploymentId]/kibana/[string refId](map<string|string[]> headers = {}, *GetDeploymentKibResourceInfoQueries queries) returns KibanaResourceInfo|error {
        string resourcePath = string `/deployments/${getEncodedUri(deploymentId)}/kibana/${getEncodedUri(refId)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Build request to migrate deployment to a different template
    #
    # + deploymentId - Identifier for the Deployment
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - The request was valid and the deployment can be migrated to the template with the provided ID 
    resource isolated function get deployments/[string deploymentId]/migrate_template(map<string|string[]> headers = {}, *MigrateDeploymentTemplateQueries queries) returns DeploymentUpdateRequest|error {
        string resourcePath = string `/deployments/${getEncodedUri(deploymentId)}/migrate_template`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get Deployment upgrade assistant status
    #
    # + deploymentId - Identifier for the Deployment
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - The Upgrade Assistant returned the status successfully 
    resource isolated function get deployments/[string deploymentId]/upgrade_assistant/status(map<string|string[]> headers = {}, *GetDeploymentUpgradeAssistantStatusQueries queries) returns DeploymentUpgradeAssistantStatusResponse|error {
        string resourcePath = string `/deployments/${getEncodedUri(deploymentId)}/upgrade_assistant/status`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Restores a shutdown resource
    #
    # + deploymentId - Identifier for the Deployment
    # + resourceKind - The kind of resource
    # + refId - User-specified RefId for the Resource (or '_main' if there is only one)
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Standard Deployment Resource Crud Response 
    resource isolated function post deployments/[string deploymentId]/["elasticsearch"|"kibana"|"apm"|"appsearch"|"enterprise_search"|"integrations_server" resourceKind]/[string refId]/_restore(map<string|string[]> headers = {}, *RestoreDeploymentResourceQueries queries) returns DeploymentResourceCrudResponse|error {
        string resourcePath = string `/deployments/${getEncodedUri(deploymentId)}/${getEncodedUri(resourceKind)}/${getEncodedUri(refId)}/_restore`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Start all instances
    #
    # + deploymentId - Identifier for the Deployment
    # + resourceKind - The kind of resource (one of elasticsearch, kibana, apm, or integrations_server)
    # + refId - User-specified RefId for the Resource (or '_main' if there is only one)
    # + headers - Headers to be sent with the request 
    # + return - The start command was issued successfully 
    resource isolated function post deployments/[string deploymentId]/[string resourceKind]/[string refId]/instances/_start(map<string|string[]> headers = {}) returns DeploymentResourceCommandResponse|error {
        string resourcePath = string `/deployments/${getEncodedUri(deploymentId)}/${getEncodedUri(resourceKind)}/${getEncodedUri(refId)}/instances/_start`;
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Stop all instances
    #
    # + deploymentId - Identifier for the Deployment
    # + resourceKind - The kind of resource (one of elasticsearch, kibana, apm, or integrations_server)
    # + refId - User-specified RefId for the Resource (or '_main' if there is only one)
    # + headers - Headers to be sent with the request 
    # + return - The stop command was issued successfully 
    resource isolated function post deployments/[string deploymentId]/[string resourceKind]/[string refId]/instances/_stop(map<string|string[]> headers = {}) returns DeploymentResourceCommandResponse|error {
        string resourcePath = string `/deployments/${getEncodedUri(deploymentId)}/${getEncodedUri(resourceKind)}/${getEncodedUri(refId)}/instances/_stop`;
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Start maintenance mode (all instances)
    #
    # + deploymentId - Identifier for the Deployment
    # + resourceKind - The kind of resource (one of elasticsearch, kibana, apm, or integrations_server)
    # + refId - User-specified RefId for the Resource (or '_main' if there is only one)
    # + headers - Headers to be sent with the request 
    # + return - The start maintenance command was issued successfully 
    resource isolated function post deployments/[string deploymentId]/[string resourceKind]/[string refId]/instances/maintenance\-mode/_start(map<string|string[]> headers = {}) returns DeploymentResourceCommandResponse|error {
        string resourcePath = string `/deployments/${getEncodedUri(deploymentId)}/${getEncodedUri(resourceKind)}/${getEncodedUri(refId)}/instances/maintenance-mode/_start`;
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Stop maintenance mode (all instances)
    #
    # + deploymentId - Identifier for the Deployment
    # + resourceKind - The kind of resource (one of elasticsearch, kibana, apm, or integrations_server)
    # + refId - User-specified RefId for the Resource (or '_main' if there is only one)
    # + headers - Headers to be sent with the request 
    # + return - The stop maintenance mode command was issued successfully 
    resource isolated function post deployments/[string deploymentId]/[string resourceKind]/[string refId]/instances/maintenance\-mode/_stop(map<string|string[]> headers = {}) returns DeploymentResourceCommandResponse|error {
        string resourcePath = string `/deployments/${getEncodedUri(deploymentId)}/${getEncodedUri(resourceKind)}/${getEncodedUri(refId)}/instances/maintenance-mode/_stop`;
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Cancel resource pending plan
    #
    # + deploymentId - Identifier for the Deployment
    # + resourceKind - The kind of resource
    # + refId - User-specified RefId for the Resource (or '_main' if there is only one)
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Standard Deployment Resource Crud Response 
    resource isolated function delete deployments/[string deploymentId]/["elasticsearch"|"kibana"|"apm"|"appsearch"|"enterprise_search"|"integrations_server" resourceKind]/[string refId]/plan/pending(map<string|string[]> headers = {}, *CancelDeploymentResourcePendingPlanQueries queries) returns DeploymentResourceCrudResponse|error {
        string resourcePath = string `/deployments/${getEncodedUri(deploymentId)}/${getEncodedUri(resourceKind)}/${getEncodedUri(refId)}/plan/pending`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Restart Deployment Stateless Resource
    #
    # + deploymentId - Identifier for the Deployment
    # + statelessResourceKind - The kind of stateless resource
    # + refId - User-specified RefId for the Resource (or '_main' if there is only one)
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - The restart command was issued successfully 
    resource isolated function post deployments/[string deploymentId]/["kibana"|"apm"|"appsearch"|"enterprise_search"|"integrations_server" statelessResourceKind]/[string refId]/_restart(map<string|string[]> headers = {}, *RestartDeploymentStatelessResourceQueries queries) returns DeploymentResourceCommandResponse|error {
        string resourcePath = string `/deployments/${getEncodedUri(deploymentId)}/${getEncodedUri(statelessResourceKind)}/${getEncodedUri(refId)}/_restart`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Shutdown Deployment Stateless Resource
    #
    # + deploymentId - Identifier for the Deployment
    # + statelessResourceKind - The kind of stateless resource
    # + refId - User-specified RefId for the Resource (or '_main' if there is only one)
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Standard response 
    resource isolated function post deployments/[string deploymentId]/["kibana"|"apm"|"appsearch"|"enterprise_search"|"integrations_server" statelessResourceKind]/[string refId]/_shutdown(map<string|string[]> headers = {}, *ShutdownDeploymentStatelessResourceQueries queries) returns DeploymentResourceCommandResponse|error {
        string resourcePath = string `/deployments/${getEncodedUri(deploymentId)}/${getEncodedUri(statelessResourceKind)}/${getEncodedUri(refId)}/_shutdown`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # List organizations
    #
    # + headers - Headers to be sent with the request 
    # + return - Organizations fetched successfully 
    resource isolated function get organizations(map<string|string[]> headers = {}) returns OrganizationList|error {
        string resourcePath = string `/organizations`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Get organization invitation
    #
    # + invitationToken - Organization invitation token
    # + headers - Headers to be sent with the request 
    # + return - Organization invitation fetched successfully 
    resource isolated function get organizations/invitations/[string invitationToken](map<string|string[]> headers = {}) returns OrganizationInvitation|error {
        string resourcePath = string `/organizations/invitations/${getEncodedUri(invitationToken)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Accept an organization invitation
    #
    # + invitationToken - Organization invitation token
    # + headers - Headers to be sent with the request 
    # + return - Organization invitation accepted successfully 
    resource isolated function post organizations/invitations/[string invitationToken]/_accept(map<string|string[]> headers = {}) returns EmptyResponse|error {
        string resourcePath = string `/organizations/invitations/${getEncodedUri(invitationToken)}/_accept`;
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Fetch organization information
    #
    # + organizationId - Identifier for the Organization
    # + headers - Headers to be sent with the request 
    # + return - Organization fetched successfully 
    resource isolated function get organizations/[string organizationId](map<string|string[]> headers = {}) returns Organization|error {
        string resourcePath = string `/organizations/${getEncodedUri(organizationId)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Update organization
    #
    # + organizationId - Identifier for the Organization
    # + headers - Headers to be sent with the request 
    # + payload - The organization to update 
    # + return - Organization updated successfully 
    resource isolated function put organizations/[string organizationId](OrganizationRequest payload, map<string|string[]> headers = {}) returns Organization|error {
        string resourcePath = string `/organizations/${getEncodedUri(organizationId)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Get domain claims
    #
    # + organizationId - Identifier for the Organization
    # + headers - Headers to be sent with the request 
    # + return - The claimed domains for the organization 
    resource isolated function get organizations/[string organizationId]/domains(map<string|string[]> headers = {}) returns GetOrganizationClaimedDomainsResponse|error {
        string resourcePath = string `/organizations/${getEncodedUri(organizationId)}/domains`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Delete domain claim
    #
    # + organizationId - Identifier for the Organization
    # + headers - Headers to be sent with the request 
    # + payload - The domain claim to remove 
    # + return - With status 200 ok to signal the domain has been unclaimed 
    resource isolated function delete organizations/[string organizationId]/domains(DeleteDomainClaimRequest payload, map<string|string[]> headers = {}) returns EmptyResponse|error {
        string resourcePath = string `/organizations/${getEncodedUri(organizationId)}/domains`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->delete(resourcePath, request, headers);
    }

    # Generate verification code
    #
    # + organizationId - Identifier for the Organization
    # + headers - Headers to be sent with the request 
    # + payload - The verification code request 
    # + return - The verification code response 
    resource isolated function post organizations/[string organizationId]/domains/_generate_verification_code(VerificationCodeRequest payload, map<string|string[]> headers = {}) returns VerificationCodeResponse|error {
        string resourcePath = string `/organizations/${getEncodedUri(organizationId)}/domains/_generate_verification_code`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Verify domain claim
    #
    # + organizationId - Identifier for the Organization
    # + headers - Headers to be sent with the request 
    # + payload - The verification code request 
    # + return - With status 200 ok to signal the domain has been claimed 
    resource isolated function post organizations/[string organizationId]/domains/_verify(DomainVerificationRequest payload, map<string|string[]> headers = {}) returns EmptyResponse|error {
        string resourcePath = string `/organizations/${getEncodedUri(organizationId)}/domains/_verify`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get organization IdP
    #
    # + organizationId - Identifier for the Organization
    # + headers - Headers to be sent with the request 
    # + return - The IdP info 
    resource isolated function get organizations/[string organizationId]/idp(map<string|string[]> headers = {}) returns OrganizationIdp|error {
        string resourcePath = string `/organizations/${getEncodedUri(organizationId)}/idp`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Setup organization IdP
    #
    # + organizationId - Identifier for the Organization
    # + headers - Headers to be sent with the request 
    # + payload - The IdP configuration 
    # + return - The IdP info 
    resource isolated function put organizations/[string organizationId]/idp(IdpConfigurationRequest payload, map<string|string[]> headers = {}) returns OrganizationIdp|error {
        string resourcePath = string `/organizations/${getEncodedUri(organizationId)}/idp`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Tear down organization IdP
    #
    # + organizationId - Identifier for the Organization
    # + headers - Headers to be sent with the request 
    # + return - The IdP was successfully removed 
    resource isolated function delete organizations/[string organizationId]/idp(map<string|string[]> headers = {}) returns EmptyResponse|error {
        string resourcePath = string `/organizations/${getEncodedUri(organizationId)}/idp`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get organization service provider SAML2 metadata.xml for configuring the identity provider
    #
    # + organizationId - Identifier for the Organization
    # + headers - Headers to be sent with the request 
    # + return - The IdP info 
    resource isolated function get organizations/[string organizationId]/idp/metadata\.xml(map<string|string[]> headers = {}) returns xml|error {
        string resourcePath = string `/organizations/${getEncodedUri(organizationId)}/idp/metadata.xml`;
        return self.clientEp->get(resourcePath, headers);
    }

    # List organization invitations
    #
    # + organizationId - Identifier for the Organization
    # + headers - Headers to be sent with the request 
    # + return - Organization invitations fetched successfully 
    resource isolated function get organizations/[string organizationId]/invitations(map<string|string[]> headers = {}) returns OrganizationInvitations|error {
        string resourcePath = string `/organizations/${getEncodedUri(organizationId)}/invitations`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Create organization invitations
    #
    # + organizationId - Identifier for the Organization
    # + headers - Headers to be sent with the request 
    # + payload - The organization invitations to create or refresh 
    # + return - Organization invitations created successfully 
    resource isolated function post organizations/[string organizationId]/invitations(OrganizationInvitationRequest payload, map<string|string[]> headers = {}) returns OrganizationInvitations|error {
        string resourcePath = string `/organizations/${getEncodedUri(organizationId)}/invitations`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Delete organization invitations
    #
    # + organizationId - Identifier for the Organization
    # + invitationTokens - CSV list of Invitation tokens
    # + headers - Headers to be sent with the request 
    # + return - Organization invitations deleted successfully 
    resource isolated function delete organizations/[string organizationId]/invitations/[string invitationTokens](map<string|string[]> headers = {}) returns EmptyResponse|error {
        string resourcePath = string `/organizations/${getEncodedUri(organizationId)}/invitations/${getEncodedUri(invitationTokens)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # List organization members
    #
    # + organizationId - Identifier for the Organization
    # + headers - Headers to be sent with the request 
    # + return - Organization members fetched successfully 
    resource isolated function get organizations/[string organizationId]/members(map<string|string[]> headers = {}) returns OrganizationMemberships|error {
        string resourcePath = string `/organizations/${getEncodedUri(organizationId)}/members`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Delete organization memberships
    #
    # + organizationId - Identifier for the Organization
    # + userIds - CSV list of User identifiers
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Organization membership deleted successfully 
    resource isolated function delete organizations/[string organizationId]/members/[string userIds](map<string|string[]> headers = {}, *DeleteOrganizationMembershipsQueries queries) returns EmptyResponse|error {
        string resourcePath = string `/organizations/${getEncodedUri(organizationId)}/members/${getEncodedUri(userIds)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get role  mappings
    #
    # + organizationId - Identifier for the Organization
    # + headers - Headers to be sent with the request 
    # + return - The IdP info 
    resource isolated function get organizations/[string organizationId]/role_mappings(map<string|string[]> headers = {}) returns GetRoleMappingsResponse|error {
        string resourcePath = string `/organizations/${getEncodedUri(organizationId)}/role_mappings`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Updates role mappings
    #
    # + organizationId - Identifier for the Organization
    # + headers - Headers to be sent with the request 
    # + payload - The role  mappings to update 
    # + return - An empty response 
    resource isolated function put organizations/[string organizationId]/role_mappings(UpdateOrganizationRoleMappingRequest payload, map<string|string[]> headers = {}) returns EmptyResponse|error {
        string resourcePath = string `/organizations/${getEncodedUri(organizationId)}/role_mappings`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete role  mappings
    #
    # + organizationId - Identifier for the Organization
    # + headers - Headers to be sent with the request 
    # + return - The mappings were successfully deleted 
    resource isolated function delete organizations/[string organizationId]/role_mappings(map<string|string[]> headers = {}) returns EmptyResponse|error {
        string resourcePath = string `/organizations/${getEncodedUri(organizationId)}/role_mappings`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get stack versions
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - The list of all available Elastic Stack versions are retrieved, including the template version and structure 
    resource isolated function get stack/versions(map<string|string[]> headers = {}, *GetVersionStacksQueries queries) returns StackVersionConfigs|error {
        string resourcePath = string `/stack/versions`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get trusted environments
    #
    # + headers - Headers to be sent with the request 
    # + return - Trusted environments for this organization 
    resource isolated function get trusted\-environments(map<string|string[]> headers = {}) returns ElasticsearchClusterTrustSettings|error {
        string resourcePath = string `/trusted-environments`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Get all API keys
    #
    # + headers - Headers to be sent with the request 
    # + return - The metadata for the API keys is retrieved 
    resource isolated function get users/auth/keys(map<string|string[]> headers = {}) returns ApiKeysResponse|error {
        string resourcePath = string `/users/auth/keys`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Create API key
    #
    # + headers - Headers to be sent with the request 
    # + payload - The request to create the API key 
    # + return - The API key is created and returned in the body of the response 
    resource isolated function post users/auth/keys(CreateApiKeyRequest payload, map<string|string[]> headers = {}) returns ApiKeyResponse|error {
        string resourcePath = string `/users/auth/keys`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Delete API keys
    #
    # + headers - Headers to be sent with the request 
    # + payload - The request to delete API keys 
    # + return - The API keys are deleted 
    resource isolated function delete users/auth/keys(DeleteApiKeysRequest payload, map<string|string[]> headers = {}) returns EmptyResponse|error {
        string resourcePath = string `/users/auth/keys`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->delete(resourcePath, request, headers);
    }

    # Get API key
    #
    # + apiKeyId - The API Key ID
    # + headers - Headers to be sent with the request 
    # + return - The API key metadata is retrieved 
    resource isolated function get users/auth/keys/[string apiKeyId](map<string|string[]> headers = {}) returns ApiKeyResponse|error {
        string resourcePath = string `/users/auth/keys/${getEncodedUri(apiKeyId)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Delete API key
    #
    # + apiKeyId - The API Key ID
    # + headers - Headers to be sent with the request 
    # + return - The API key is deleted 
    resource isolated function delete users/auth/keys/[string apiKeyId](map<string|string[]> headers = {}) returns EmptyResponse|error {
        string resourcePath = string `/users/auth/keys/${getEncodedUri(apiKeyId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Add Role Assignments
    #
    # + userId - Identifier for the user; include realm name and id if required
    # + headers - Headers to be sent with the request 
    # + payload - The Role Assignments to add 
    # + return - Role Assignments were successfully added to the target User 
    resource isolated function post users/[string userId]/role_assignments(RoleAssignments payload, map<string|string[]> headers = {}) returns EmptyResponse|error {
        string resourcePath = string `/users/${getEncodedUri(userId)}/role_assignments`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Remove Role Assignments
    #
    # + userId - Identifier for the user; include realm name and id if required
    # + headers - Headers to be sent with the request 
    # + payload - The Role Assignments to remove 
    # + return - Role Assignments were successfully removed from the target User 
    resource isolated function delete users/[string userId]/role_assignments(RoleAssignments payload, map<string|string[]> headers = {}) returns EmptyResponse|error {
        string resourcePath = string `/users/${getEncodedUri(userId)}/role_assignments`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->delete(resourcePath, request, headers);
    }
}
